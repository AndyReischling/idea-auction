'use client';

/**
 * REALISTIC ACTIVITY FIX & CONSTANT REAL-TIME UPDATES IMPLEMENTED:
 * 
 * Issues Fixed:
 * - Users no longer gain money for generating opinions
 * - 'generate' and 'earn' are now separate activity types
 * - Generate activities show $0.00 instead of positive amounts
 * - Only legitimate earnings (trading wins, bet wins) show positive amounts
 * - Bot system updated to not reward opinion generation
 * - Feed now updates constantly with real-time activity
 * 
 * Changes Made:
 * - Updated unifiedTransactionProcessor to set generate amount to 0
 * - Fixed bot system to use 'generate' type with 0 amount
 * - Updated activity descriptions to differentiate generate vs earn
 * - Added test function to verify realistic behavior
 * 
 * REAL-TIME UPDATE SYSTEM:
 * - Relative times update every 10 seconds (was 60 seconds)
 * - Full feed refresh every 3 seconds for constant updates
 * - Bot activity generation every 5 seconds to keep feed active
 * - Activity boost check every 15 seconds to maintain flow
 * - Immediate kickstart activity when page loads
 * - Enhanced header with live indicators and auto-refresh status
 * - Manual "INSTANT LIVE ACTIVITY" button for immediate content generation
 * - Firebase real-time subscriptions for multi-user updates
 */

import { useEffect, useState, useCallback, useRef } from 'react';
import { useRouter } from 'next/navigation';
import Sidebar from '../components/Sidebar';
import '../global.css';
import styles from './page.module.css';
import { ScanSmiley } from '@phosphor-icons/react/dist/icons/ScanSmiley';
import { Balloon } from '@phosphor-icons/react/dist/icons/Balloon';
import { Rss, WalletIcon } from '@phosphor-icons/react/dist/ssr';
import { Wallet } from '@phosphor-icons/react';
import { Money } from '@phosphor-icons/react';
import { CurrencyDollar } from '@phosphor-icons/react';
import { Plus } from '@phosphor-icons/react';
import { HandPeace } from '@phosphor-icons/react';
import { DiceSix } from '@phosphor-icons/react';
import { ChartLineDown } from '@phosphor-icons/react';
import AuthButton from '../components/AuthButton';
import { useAuth } from '../lib/auth-context';
import { firebaseActivityService, LocalActivityItem } from '../lib/firebase-activity';
import { dataReconciliationService } from '../lib/data-reconciliation';
import { realtimeDataService } from '../lib/realtime-data-service';

// REAL-TIME FEED: Global Event System for Instant Updates
class RealTimeFeedManager {
  private listeners: Set<(activity: ActivityFeedItem) => void> = new Set();
  private static instance: RealTimeFeedManager;

  static getInstance(): RealTimeFeedManager {
    if (!RealTimeFeedManager.instance) {
      RealTimeFeedManager.instance = new RealTimeFeedManager();
    }
    return RealTimeFeedManager.instance;
  }

  // Subscribe to real-time activity updates
  subscribe(callback: (activity: ActivityFeedItem) => void): () => void {
    this.listeners.add(callback);
    console.log(`ðŸ”´ LIVE FEED: New subscriber added (${this.listeners.size} total)`);
    
    return () => {
      this.listeners.delete(callback);
      console.log(`ðŸ”´ LIVE FEED: Subscriber removed (${this.listeners.size} remaining)`);
    };
  }

  // Push new activity to all subscribers immediately
  pushActivity(activity: Omit<ActivityFeedItem, 'id' | 'relativeTime'>) {
    const fullActivity: ActivityFeedItem = {
      ...activity,
      id: `live_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      relativeTime: 'just now'
    };

    console.log(`ðŸ”´ LIVE FEED: Broadcasting new activity: ${fullActivity.username} - ${fullActivity.type}`);
    
    // Notify all subscribers immediately
    this.listeners.forEach(callback => {
      try {
        callback(fullActivity);
      } catch (error) {
        console.error('ðŸ”´ LIVE FEED: Error in subscriber callback:', error);
      }
    });

    return fullActivity;
  }

  // Get current subscriber count
  getSubscriberCount(): number {
    return this.listeners.size;
  }
}

// Force CSS to be processed
if (typeof window !== 'undefined') {
  // This ensures CSS modules are processed
  console.log('CSS modules loaded:', styles);
  
  // Add real-time feed animations
  const style = document.createElement('style');
  style.textContent = `
    @keyframes slideInFromTop {
      0% {
        transform: translateY(-20px);
        opacity: 0;
      }
      100% {
        transform: translateY(0);
        opacity: 1;
      }
    }
    
    @keyframes fadeIn {
      0% {
        opacity: 0;
      }
      100% {
        opacity: 1;
      }
    }
    
    @keyframes pulse {
      0% {
        transform: scale(1);
        opacity: 1;
      }
      50% {
        transform: scale(1.1);
        opacity: 0.7;
      }
      100% {
        transform: scale(1);
        opacity: 1;
      }
    }
  `;
  document.head.appendChild(style);
}

interface ActivityFeedItem {
  id: string;
  type: 'buy' | 'sell' | 'bet' | 'bet_place' | 'bet_win' | 'bet_loss' | 'earn' | 'generate' | 'short_place' | 'short_win' | 'short_loss';
  username: string;
  opinionText?: string;
  opinionId?: string;
  amount: number;
  price?: number;
  quantity?: number;
  targetUser?: string;
  betType?: 'increase' | 'decrease';
  targetPercentage?: number;
  timeframe?: number;
  shortDetails?: {
    targetDropPercentage: number;
    startingPrice: number;
    targetPrice: number;
    potentialWinnings: number;
    timeLimit: number;
  };
  timestamp: string;
  relativeTime: string;
  isBot?: boolean;
}

interface UserProfile {
  username: string;
  balance: number;
}

interface TransactionDetail {
  id: string;
  type: string;
  username: string;
  opinionText?: string;
  opinionId?: string;
  amount: number;
  price?: number;
  quantity?: number;
  targetUser?: string;
  betType?: 'increase' | 'decrease';
  targetPercentage?: number;
  timeframe?: number;
  shortDetails?: {
    targetDropPercentage: number;
    startingPrice: number;
    targetPrice: number;
    potentialWinnings: number;
    timeLimit: number;
  };
  timestamp: string;
  isBot?: boolean;
  fullDescription: string;
  additionalDetails?: {
    multiplier?: number;
    potentialPayout?: number;
    volatilityRating?: string;
    expiryDate?: string;
    betStatus?: string;
    shortProgress?: number;
  };
}

// Enhanced interfaces for betting functionality
interface AdvancedBet {
  id: string;
  bettor: string;
  targetUser: string;
  betType: 'increase' | 'decrease';
  targetPercentage: number;
  amount: number;
  timeFrame: number;
  initialPortfolioValue: number;
  currentPortfolioValue: number;
  placedDate: string;
  expiryDate: string;
  status: 'active' | 'won' | 'lost' | 'expired';
  multiplier: number;
  potentialPayout: number;
  volatilityRating: 'Low' | 'Medium' | 'High' | 'Extreme';
}

interface BetForm {
  betType: 'increase' | 'decrease';
  targetPercentage: number;
  amount: number;
  timeFrame: number;
}

// NEW: Enhanced Activity Detail Modal Component with Full Trading and Betting Functionality
interface ActivityDetailModalProps {
  activity: ActivityFeedItem;
  onClose: () => void;
  currentUser: UserProfile;
  onUpdateUser: (user: UserProfile) => void;
}

const ActivityDetailModal: React.FC<ActivityDetailModalProps> = ({ activity, onClose, currentUser, onUpdateUser }) => {
  const router = useRouter();
  const [quantity, setQuantity] = useState(1);
  const [currentPrice, setCurrentPrice] = useState(10.00);
  const [message, setMessage] = useState('');
  const [isClient, setIsClient] = useState(false);
  
  // Short settings state
  const [shortSettings, setShortSettings] = useState({
    betAmount: 100,
    targetDropPercentage: 25,
    timeLimit: 24
  });

  // Portfolio betting state
  const [showBettingInterface, setShowBettingInterface] = useState(false);
  const [betForm, setBetForm] = useState<BetForm>({
    betType: 'increase',
    targetPercentage: 10,
    amount: 100,
    timeFrame: 7
  });
  const [targetUserData, setTargetUserData] = useState<any>(null);

  // Market data state
  const [marketData, setMarketData] = useState({
    timesPurchased: 0,
    timesSold: 0,
    currentPrice: 10.00,
    basePrice: 10.00
  });

  // Ownership state  
  const [ownedQuantity, setOwnedQuantity] = useState(0);
  const [alreadyOwned, setAlreadyOwned] = useState(false);
  const [hasActiveShort, setHasActiveShort] = useState(false);

  // Portfolio betting functions
  const calculateBetMultiplier = (
    betType: 'increase' | 'decrease',
    targetPercentage: number,
    timeFrame: number,
    userVolatility: number = 15,
    recentPerformance: number = 0
  ): number => {
    let baseMultiplier = 1.0;
    
    // Percentage difficulty multiplier (1-100% range)
    if (targetPercentage >= 1 && targetPercentage <= 5) {
      baseMultiplier = 1.2;
    } else if (targetPercentage > 5 && targetPercentage <= 15) {
      baseMultiplier = 1.5;
    } else if (targetPercentage > 15 && targetPercentage <= 25) {
      baseMultiplier = 2.0;
    } else if (targetPercentage > 25 && targetPercentage <= 40) {
      baseMultiplier = 3.0;
    } else if (targetPercentage > 40 && targetPercentage <= 60) {
      baseMultiplier = 4.0;
    } else if (targetPercentage > 60 && targetPercentage <= 80) {
      baseMultiplier = 5.0;
    } else if (targetPercentage > 80 && targetPercentage <= 100) {
      baseMultiplier = 6.0;
    }
    
    // Time multiplier
    let timeMultiplier = 1.0;
    if (timeFrame <= 1) {
      timeMultiplier = 1.5;
    } else if (timeFrame <= 3) {
      timeMultiplier = 1.3;
    } else if (timeFrame <= 7) {
      timeMultiplier = 1.0;
    } else if (timeFrame <= 14) {
      timeMultiplier = 0.9;
    } else {
      timeMultiplier = 0.8;
    }
    
    const volatilityFactor = Math.max(0.8, Math.min(2.0, userVolatility / 10));
    const trendAlignment = betType === 'increase' 
      ? (recentPerformance > 5 ? 0.7 : recentPerformance < -5 ? 1.4 : 1.0)
      : (recentPerformance < -5 ? 0.7 : recentPerformance > 5 ? 1.4 : 1.0);
    
    const finalMultiplier = baseMultiplier * timeMultiplier * volatilityFactor * trendAlignment;
    return Math.max(1.1, Math.min(15.0, Math.round(finalMultiplier * 10) / 10));
  };

  const getVolatilityRating = (percentage: number): 'Low' | 'Medium' | 'High' | 'Extreme' => {
    if (percentage >= 1 && percentage <= 10) return 'Low';
    if (percentage > 10 && percentage <= 30) return 'Medium';
    if (percentage > 30 && percentage <= 70) return 'High';
    return 'Extreme';
  };

  const getDifficultyLabel = (percentage: number): string => {
    if (percentage >= 1 && percentage <= 5) return 'Very Easy';
    if (percentage > 5 && percentage <= 15) return 'Easy';
    if (percentage > 15 && percentage <= 25) return 'Medium';
    if (percentage > 25 && percentage <= 40) return 'Hard';
    if (percentage > 40 && percentage <= 60) return 'Very Hard';
    if (percentage > 60 && percentage <= 80) return 'Extreme';
    return 'Nearly Impossible';
  };

  // Load target user data for betting
  const loadTargetUserData = (username: string) => {
    // Simulate user data - in real app, this would fetch from API/storage
    const mockUserData = {
      username: username,
      portfolioValue: Math.floor(Math.random() * 100000) + 10000,
      volatility: Math.floor(Math.random() * 30) + 5,
      recentPerformance: (Math.random() - 0.5) * 20,
      isCurrentUser: username === currentUser.username,
      isBot: activity.isBot || false
    };
    setTargetUserData(mockUserData);
  };

  // Handle portfolio bet placement
  const handlePlaceBet = () => {
    if (!targetUserData || !isClient) return;

    if (targetUserData.isCurrentUser) {
      setMessage('You cannot bet on your own portfolio!');
      setTimeout(() => setMessage(''), 3000);
      return;
    }

    if (betForm.amount <= 0 || betForm.amount > currentUser.balance) {
      setMessage('Invalid bet amount or insufficient funds!');
      setTimeout(() => setMessage(''), 3000);
      return;
    }

    const multiplier = calculateBetMultiplier(
      betForm.betType,
      betForm.targetPercentage,
      betForm.timeFrame,
      targetUserData.volatility,
      targetUserData.recentPerformance
    );

    const potentialPayout = Math.round(betForm.amount * multiplier);
    const volatilityRating = getVolatilityRating(betForm.targetPercentage);

    const newBet: AdvancedBet = {
      id: Date.now().toString(),
      bettor: currentUser.username,
      targetUser: targetUserData.username,
      betType: betForm.betType,
      targetPercentage: betForm.targetPercentage,
      amount: betForm.amount,
      timeFrame: betForm.timeFrame,
      initialPortfolioValue: targetUserData.portfolioValue,
      currentPortfolioValue: targetUserData.portfolioValue,
      placedDate: new Date().toLocaleDateString(),
      expiryDate: new Date(Date.now() + betForm.timeFrame * 24 * 60 * 60 * 1000).toLocaleDateString(),
      status: 'active',
      multiplier,
      potentialPayout,
      volatilityRating
    };

    // Update user balance
    const updatedUser = {
      ...currentUser,
      balance: currentUser.balance - betForm.amount
    };
    onUpdateUser(updatedUser);
    safeSetToStorage('userProfile', updatedUser);

    // Save bet
    const existingBets = safeGetFromStorage('advancedBets', []);
    const updatedBets = [...existingBets, newBet];
    safeSetToStorage('advancedBets', updatedBets);

    // Add transaction
    const transactions = safeGetFromStorage('transactions', []);
    const newTransaction = {
      id: Date.now().toString(),
      type: 'bet_place',
      amount: -betForm.amount,
      date: new Date().toLocaleDateString(),
      description: `Bet on ${targetUserData.username}: ${betForm.betType} ${betForm.targetPercentage}% in ${betForm.timeFrame}d (${multiplier}x multiplier)`
    };
    
    transactions.unshift(newTransaction);
    safeSetToStorage('transactions', transactions.slice(0, 50));

    // Call global feed tracking
    if (typeof window !== 'undefined' && (window as any).addToGlobalFeed) {
      (window as any).addToGlobalFeed({
        type: 'bet_place',
        username: currentUser.username,
        targetUser: targetUserData.username,
        betType: betForm.betType,
        targetPercentage: betForm.targetPercentage,
        timeframe: betForm.timeFrame,
        amount: -betForm.amount,
        timestamp: new Date().toISOString(),
        isBot: false
      });
    }

    setShowBettingInterface(false);
  };

  // Initialize betting data when modal opens
  useEffect(() => {
    if (!isClient || !activity.username) return;
    
    // Load target user data for betting if it's a different user
    if (activity.username !== currentUser.username) {
      loadTargetUserData(activity.username);
    }
  }, [isClient, activity.username, currentUser.username]);

  // Safe localStorage helpers
  const safeGetFromStorage = (key: string, defaultValue: any = null) => {
    if (typeof window === 'undefined') return defaultValue;
    try {
      const item = localStorage.getItem(key);
      return item ? JSON.parse(item) : defaultValue;
    } catch (error) {
      console.error(`Error reading localStorage key ${key}:`, error);
      return defaultValue;
    }
  };

  const safeSetToStorage = (key: string, value: any) => {
    if (typeof window === 'undefined') return;
    try {
      localStorage.setItem(key, JSON.stringify(value));
    } catch (error) {
      console.error(`Error writing to localStorage key ${key}:`, error);
    }
  };

  // Price calculation matching sidebar logic
  const calculatePrice = (timesPurchased: number, timesSold: number, basePrice: number = 10.00): number => {
    const netDemand = timesPurchased - timesSold;
    let priceMultiplier;
    
    if (netDemand >= 0) {
      priceMultiplier = Math.pow(1.001, netDemand);
    } else {
      priceMultiplier = Math.max(0.1, Math.pow(0.999, Math.abs(netDemand)));
    }
    
    const calculatedPrice = Math.max(basePrice * 0.5, basePrice * priceMultiplier);
    return Math.round(calculatedPrice * 100) / 100;
  };

  // Get current market data for opinion
  const getOpinionMarketData = (opinionText: string) => {
    if (!isClient) return { timesPurchased: 0, timesSold: 0, currentPrice: 10.00, basePrice: 10.00 };
    
    const existingData = safeGetFromStorage('opinionMarketData', {});
    
    if (existingData[opinionText]) {
      return existingData[opinionText];
    }
    
    return { timesPurchased: 0, timesSold: 0, currentPrice: 10.00, basePrice: 10.00 };
  };

  // Update market data with new transaction
  const updateOpinionMarketData = (opinionText: string, action: 'buy' | 'sell') => {
    const existingData = safeGetFromStorage('opinionMarketData', {});
    
    if (!existingData[opinionText]) {
      existingData[opinionText] = { timesPurchased: 0, timesSold: 0, currentPrice: 10.00, basePrice: 10.00 };
    }
    
    if (action === 'buy') {
      existingData[opinionText].timesPurchased += 1;
    } else {
      existingData[opinionText].timesSold += 1;
    }
    
    existingData[opinionText].currentPrice = calculatePrice(
      existingData[opinionText].timesPurchased,
      existingData[opinionText].timesSold,
      existingData[opinionText].basePrice
    );
    
    safeSetToStorage('opinionMarketData', existingData);
    return existingData[opinionText];
  };

  // Calculate sell price (95% of current price)
  const calculateSellPrice = (currentPrice: number): number => {
    return Math.round(currentPrice * 0.95 * 100) / 100;
  };

  // Calculate short winnings
  const calculateShortWinnings = (betAmount: number, targetDropPercentage: number, timeLimit: number): number => {
    const baseMultiplier = Math.max(1.1, 1 + (targetDropPercentage / 100));
    let timeBonus = 1;
    
    if (timeLimit <= 6) timeBonus = 1.5;
    else if (timeLimit <= 12) timeBonus = 1.3;
    else if (timeLimit <= 24) timeBonus = 1.1;
    
    let riskMultiplier = 1;
    if (targetDropPercentage >= 80) riskMultiplier = 10;
    else if (targetDropPercentage >= 50) riskMultiplier = 5;
    else if (targetDropPercentage >= 30) riskMultiplier = 3;
    else if (targetDropPercentage >= 20) riskMultiplier = 2;
    
    const totalMultiplier = baseMultiplier * timeBonus * riskMultiplier;
    return Math.round(betAmount * totalMultiplier * 100) / 100;
  };

  // Load market data and ownership status
  useEffect(() => {
    if (!isClient || !activity.opinionText) return;

    const data = getOpinionMarketData(activity.opinionText);
    setMarketData(data);
    setCurrentPrice(data.currentPrice);

    // Check ownership
    const ownedOpinions = safeGetFromStorage('ownedOpinions', []);
    const owned = ownedOpinions.find((op: any) => op.text === activity.opinionText);
    if (owned) {
      setOwnedQuantity(owned.quantity || 0);
      setAlreadyOwned(true);
    }

    // Check for active short position
    const shortPositions = safeGetFromStorage('shortPositions', []);
    const activeShort = shortPositions.find((short: any) => 
      short.opinionText === activity.opinionText && short.status === 'active'
    );
    setHasActiveShort(!!activeShort);
  }, [isClient, activity.opinionText]);

  // Rapid trading restriction function with enhanced date handling
  const getRapidTradeCount = (opinionText: string, timeframeMinutes: number): number => {
    if (!isClient) return 0;
    
    const transactions = safeGetFromStorage('transactions', []);
    const cutoffTime = new Date();
    cutoffTime.setMinutes(cutoffTime.getMinutes() - timeframeMinutes);
    
    const recentTrades = transactions.filter((t: any) => {
      if (t.type !== 'buy') return false;
      if (!t.opinionText) return false;
      
      const transactionOpinion = t.opinionText.replace('...', '');
      const targetOpinion = opinionText.slice(0, 47);
      
      const opinionMatches = transactionOpinion.includes(targetOpinion.slice(0, 20)) || 
                            targetOpinion.includes(transactionOpinion.slice(0, 20));
      
      if (!opinionMatches) return false;
      
      let transactionDate: Date;
      
      if (t.timestamp) {
        transactionDate = new Date(t.timestamp);
      } else if (t.date) {
        transactionDate = new Date(t.date);
      } else {
        return false;
      }
      
      if (isNaN(transactionDate.getTime())) return false;
      
      return transactionDate > cutoffTime;
    });
    
    return recentTrades.length;
  };

  // Enhanced buy handler with better rapid trading enforcement
  const handleBuy = () => {
    if (!activity.opinionText || !isClient) return;

    const rapidTradeCount = getRapidTradeCount(activity.opinionText, 10);
    
    if (rapidTradeCount >= 3) {
      setMessage('âš ï¸ TRADING LIMIT REACHED! You can only make 3 purchases per 10 minutes for each opinion. Please wait before purchasing again.');
      setTimeout(() => setMessage(''), 7000);
      return;
    }

    const totalCost = currentPrice * quantity;
    if (currentUser.balance < totalCost) {
      setMessage('ðŸ’° Insufficient funds!');
      setTimeout(() => setMessage(''), 3000);
      return;
    }

    // Update user balance
    const updatedUser = {
      ...currentUser,
      balance: currentUser.balance - totalCost
    };
    onUpdateUser(updatedUser);
    safeSetToStorage('userProfile', updatedUser);

    // Update market data
    const updatedMarketData = updateOpinionMarketData(activity.opinionText, 'buy');
    setMarketData(updatedMarketData);
    setCurrentPrice(updatedMarketData.currentPrice);

    // Add to owned opinions
    const ownedOpinions = safeGetFromStorage('ownedOpinions', []);
    const existingOpinion = ownedOpinions.find((op: any) => op.text === activity.opinionText);
    
    if (existingOpinion) {
      existingOpinion.quantity += quantity;
      existingOpinion.currentPrice = updatedMarketData.currentPrice;
    } else {
      ownedOpinions.push({
        id: activity.opinionId || Date.now().toString(),
        text: activity.opinionText,
        purchasePrice: currentPrice,
        currentPrice: updatedMarketData.currentPrice,
        purchaseDate: new Date().toLocaleDateString(),
        quantity: quantity
      });
    }
    safeSetToStorage('ownedOpinions', ownedOpinions);

    // Update local state
    setOwnedQuantity(ownedQuantity + quantity);
    setAlreadyOwned(true);

    // Add transaction with PRECISE timestamp for rapid trading tracking
    const transactions = safeGetFromStorage('transactions', []);
    const newTransaction = {
      id: Date.now().toString(),
      type: 'buy',
      opinionId: activity.opinionId,
      opinionText: activity.opinionText.length > 47 ? activity.opinionText.slice(0, 47) + '...' : activity.opinionText,
      amount: -totalCost,
      price: currentPrice,
      quantity: quantity,
      date: new Date().toLocaleDateString(),
      timestamp: new Date().toISOString()
    };
    
    transactions.unshift(newTransaction);
    safeSetToStorage('transactions', transactions.slice(0, 50));

    // Call global feed tracking
    if (typeof window !== 'undefined' && (window as any).addToGlobalFeed) {
      (window as any).addToGlobalFeed({
        type: 'buy',
        username: currentUser.username,
        opinionText: activity.opinionText,
        opinionId: activity.opinionId,
        amount: -totalCost,
        price: currentPrice,
        quantity: quantity,
        timestamp: new Date().toISOString(),
        isBot: false
      });
    }

    setMessage(`âœ… Bought ${quantity} shares for ${totalCost.toFixed(2)}! (${getRapidTradeCount(activity.opinionText, 10) + 1}/3 trades in 10min)`);
    setTimeout(() => setMessage(''), 3000);
  };

  // Handle sell opinion
  const handleSell = () => {
    if (!activity.opinionText || !alreadyOwned || ownedQuantity === 0 || !isClient) return;

    // Check for active short position penalty
    const shortPositions = safeGetFromStorage('shortPositions', []);
    const activeShort = shortPositions.find((short: any) => 
      short.opinionText === activity.opinionText && short.status === 'active'
    );
    
    if (activeShort) {
      const unitsToBuy = activeShort.targetDropPercentage;
      const costPerUnit = currentPrice;
      const totalPenaltyCost = Math.round(unitsToBuy * costPerUnit * 100) / 100;
      
      const updatedUser = {
        ...currentUser,
        balance: currentUser.balance - totalPenaltyCost
      };
      onUpdateUser(updatedUser);
      safeSetToStorage('userProfile', updatedUser);
      
      // Mark short as lost
      const updatedShorts = shortPositions.map((short: any) => 
        short.id === activeShort.id ? { ...short, status: 'lost' } : short
      );
      safeSetToStorage('shortPositions', updatedShorts);
      setHasActiveShort(false);
      
      setMessage(`âš ï¸ Short position cancelled! Penalty: ${totalPenaltyCost.toFixed(2)}`);
      setTimeout(() => setMessage(''), 5000);
      return;
    }

    const actualSellPrice = calculateSellPrice(currentPrice);
    const totalReceived = actualSellPrice;

    // Update user balance
    const updatedUser = {
      ...currentUser,
      balance: currentUser.balance + totalReceived
    };
    onUpdateUser(updatedUser);
    safeSetToStorage('userProfile', updatedUser);

    // Update market data
    const updatedMarketData = updateOpinionMarketData(activity.opinionText, 'sell');
    setMarketData(updatedMarketData);
    setCurrentPrice(updatedMarketData.currentPrice);

    // Update owned opinions
    const ownedOpinions = safeGetFromStorage('ownedOpinions', []);
    const updatedOwnedOpinions = ownedOpinions.map((asset: any) => {
      if (asset.text === activity.opinionText) {
        const newQuantity = asset.quantity - 1;
        return {
          ...asset,
          quantity: newQuantity,
          currentPrice: updatedMarketData.currentPrice
        };
      }
      return asset;
    }).filter((asset: any) => asset.quantity > 0);

    safeSetToStorage('ownedOpinions', updatedOwnedOpinions);

    // Update local state
    const newQuantity = ownedQuantity - 1;
    setOwnedQuantity(newQuantity);
    if (newQuantity === 0) {
      setAlreadyOwned(false);
    }

    // Add transaction
    const transactions = safeGetFromStorage('transactions', []);
    transactions.unshift({
      id: Date.now().toString(),
      type: 'sell',
      opinionId: activity.opinionId,
      opinionText: activity.opinionText,
      amount: totalReceived,
      price: actualSellPrice,
      quantity: 1,
      date: new Date().toLocaleDateString()
    });
    safeSetToStorage('transactions', transactions.slice(0, 50));

    // Call global feed tracking
    if (typeof window !== 'undefined' && (window as any).addToGlobalFeed) {
      (window as any).addToGlobalFeed({
        type: 'sell',
        username: currentUser.username,
        opinionText: activity.opinionText,
        opinionId: activity.opinionId,
        amount: totalReceived,
        price: actualSellPrice,
        quantity: 1,
        timestamp: new Date().toISOString(),
        isBot: false
      });
    }

    setMessage(`ðŸ’° Sold 1 share for ${totalReceived.toFixed(2)}!`);
    setTimeout(() => setMessage(''), 3000);
  };

  // Handle short position
  const handleShort = () => {
    if (!activity.opinionText || !isClient) return;

    if (currentUser.balance < shortSettings.betAmount) {
      setMessage('ðŸ’° Insufficient funds for short bet!');
      setTimeout(() => setMessage(''), 3000);
      return;
    }

    if (hasActiveShort) {
      setMessage('âš ï¸ You already have an active short position on this opinion!');
      setTimeout(() => setMessage(''), 3000);
      return;
    }

    if (ownedQuantity > 0) {
      setMessage('âš ï¸ Cannot short opinions you own. Sell your position first.');
      setTimeout(() => setMessage(''), 3000);
      return;
    }

    const targetPrice = Math.round((currentPrice * (1 - shortSettings.targetDropPercentage / 100)) * 100) / 100;
    const potentialWinnings = calculateShortWinnings(
      shortSettings.betAmount,
      shortSettings.targetDropPercentage,
      shortSettings.timeLimit
    );

    // Update user balance
    const updatedUser = {
      ...currentUser,
      balance: currentUser.balance - shortSettings.betAmount
    };
    onUpdateUser(updatedUser);
    safeSetToStorage('userProfile', updatedUser);

    // Create short position
    const shortPositions = safeGetFromStorage('shortPositions', []);
    const expirationTime = new Date();
    expirationTime.setHours(expirationTime.getHours() + shortSettings.timeLimit);

    const newShort = {
      id: Date.now().toString(),
      opinionText: activity.opinionText,
      opinionId: activity.opinionId || Date.now().toString(),
      betAmount: shortSettings.betAmount,
      targetDropPercentage: shortSettings.targetDropPercentage,
      startingPrice: currentPrice,
      targetPrice,
      potentialWinnings,
      expirationDate: expirationTime.toISOString(),
      createdDate: new Date().toISOString(),
      status: 'active'
    };

    shortPositions.push(newShort);
    safeSetToStorage('shortPositions', shortPositions);
    setHasActiveShort(true);

    // Add transaction
    const transactions = safeGetFromStorage('transactions', []);
    transactions.unshift({
      id: Date.now().toString(),
      type: 'short_place',
      opinionText: activity.opinionText,
      amount: -shortSettings.betAmount,
      date: new Date().toLocaleDateString()
    });
    safeSetToStorage('transactions', transactions.slice(0, 50));

    // Call global feed tracking
    if (typeof window !== 'undefined' && (window as any).addToGlobalFeed) {
      (window as any).addToGlobalFeed({
        type: 'short_place',
        username: currentUser.username,
        opinionText: activity.opinionText,
        opinionId: activity.opinionId,
        amount: -shortSettings.betAmount,
        timestamp: new Date().toISOString(),
        isBot: false
      });
    }

    setMessage(`ðŸ“‰ Short position placed! Target: ${shortSettings.targetDropPercentage}% drop`);
    setTimeout(() => setMessage(''), 3000);
  };

  // Get activity description
  const getActivityDescription = () => {
    const { type, username, opinionText, targetUser, betType, targetPercentage, isBot } = activity;
    const userPrefix = isBot ? 'Bot' : 'User';
    
    switch (type) {
      case 'buy':
        return `${userPrefix} ${username} bought ${activity.quantity || 1} shares of "${opinionText}"`;
      case 'sell':
        return `${userPrefix} ${username} sold ${activity.quantity || 1} shares of "${opinionText}"`;
      case 'generate':
      case 'earn':
        return `${userPrefix} ${username} generated opinion: "${opinionText}"`;
      case 'short_place':
        return `${userPrefix} ${username} placed a short bet on "${opinionText}"`;
      case 'short_win':
        return `${userPrefix} ${username} won a short bet on "${opinionText}"`;
      case 'short_loss':
        return `${userPrefix} ${username} lost a short bet on "${opinionText}"`;
      case 'bet_place':
        return `${userPrefix} ${username} bet that ${targetUser}'s portfolio will ${betType} by ${targetPercentage}%`;
      case 'bet_win':
        return `${userPrefix} ${username} won a portfolio bet on ${targetUser}`;
      case 'bet_loss':
        return `${userPrefix} ${username} lost a portfolio bet on ${targetUser}`;
      default:
        return `${userPrefix} ${username} performed ${type}`;
    }
  };

  // Check if activity is idea-related (shows trading interface)
  const isIdeaRelated = () => {
    return ['buy', 'sell', 'generate', 'earn', 'short_place', 'short_win', 'short_loss'].includes(activity.type);
  };

  // Check if activity is portfolio bet related (shows target user link)
  const isPortfolioBet = () => {
    return ['bet_place', 'bet_win', 'bet_loss'].includes(activity.type);
  };

  // Handle navigation to target user profile
  const handleViewTargetProfile = () => {
    if (activity.targetUser) {
      router.push(`/users/${activity.targetUser}`);
      onClose();
    }
  };

  // Initialize client-side state
  useEffect(() => {
    setIsClient(true);
  }, []);

  if (!isClient) {
    return null;
  }

  return (
    <div 
      className="modal-overlay"
      onClick={(e) => {
        if (e.target === e.currentTarget) onClose();
      }}
    >
      <div 
        className="modal-content"
        style={{
          width: '500px',
          height: '500px',
          maxWidth: '90vw',
          maxHeight: '90vh',
          position: 'relative',
          display: 'flex',
          flexDirection: 'column',
          overflow: 'hidden'
        }}
      >
        {/* Header with close button - Fixed at top */}
        <div style={{
          display: 'flex',
          justifyContent: 'space-between',
          alignItems: 'center',
          marginBottom: '20px',
          borderBottom: '2px solid var(--border-primary)',
          paddingBottom: '15px',
          flexShrink: 0
        }}>
          <h3 style={{ 
            margin: 0, 
            fontSize: '18px', 
            fontWeight: '700',
            color: 'var(--text-primary)'
          }}>
            Activity Details
          </h3>
          <button
            onClick={onClose}
            style={{
              background: 'none',
              border: 'none',
              fontSize: '20px',
              cursor: 'pointer',
              color: 'var(--text-secondary)',
              padding: '5px'
            }}
          >
            âœ•
          </button>
        </div>

        {/* Scrollable content area */}
        <div style={{
          flex: 1,
          overflowY: 'auto',
          paddingRight: '5px'
        }}>
          {/* Enhanced Activity Description with Clickable Username */}
          <div style={{
            padding: '15px',
            backgroundColor: 'var(--bg-elevated)',
            borderRadius: 'var(--radius-lg)',
            border: '2px solid var(--border-primary)',
            marginBottom: '20px'
          }}>
            <p style={{ 
              margin: '0 0 10px 0', 
              fontSize: '14px', 
              lineHeight: '1.4',
              color: 'var(--text-primary)'
            }}>
              {getActivityDescription()}
            </p>
            
            {/* User Profile Link Section */}
            <div style={{
              display: 'flex',
              alignItems: 'center',
              gap: '10px',
              marginBottom: '10px',
              padding: '8px',
              backgroundColor: 'rgba(59, 130, 246, 0.1)',
              borderRadius: '6px',
              border: '1px solid rgba(59, 130, 246, 0.2)'
            }}>
              <span style={{ fontSize: '12px', color: '#4b5563' }}>User:</span>
              <button
                onClick={() => {
                  router.push(`/users/${activity.username}`);
                  onClose();
                }}
                style={{
                  background: 'none',
                  border: 'none',
                  color: activity.isBot ? '#10b981' : '#3b82f6',
                  cursor: 'pointer',
                  textDecoration: 'underline',
                  fontSize: '14px',
                  fontWeight: '600',
                  display: 'flex',
                  alignItems: 'center',
                  gap: '4px'
                }}
              >
                {activity.isBot ? 'Bot' : 'User'} {activity.username}
              </button>
              

            </div>
            
            <div style={{
              display: 'flex',
              gap: '15px',
              fontSize: '12px',
              color: 'var(--text-secondary)'
            }}>
              <span>${Math.abs(activity.amount).toFixed(2)}</span>
              <span>{activity.relativeTime}</span>
            </div>
          </div>

          {/* Portfolio Betting Interface */}
          {showBettingInterface && targetUserData && !targetUserData.isCurrentUser && (
            <div style={{
              padding: '20px',
              backgroundColor: 'white',
              borderRadius: 'var(--radius-lg)',
              border: '2px solid var(--border-primary)',
              marginBottom: '20px',
              boxShadow: '0 4px 8px rgba(0,0,0,0.1)'
            }}>
              <h4 style={{ 
                margin: '0 0 15px 0', 
                fontSize: '18px',
                color: '#1f2937',
                fontWeight: '700'
              }}>
                Bet on {targetUserData.username}'s Portfolio
              </h4>
              
              <div style={{
                display: 'grid',
                gridTemplateColumns: '1fr 1fr',
                gap: '15px',
                marginBottom: '15px'
              }}>
                {/* Bet Type */}
                <div>
                  <label style={{ 
                    fontSize: '14px', 
                    color: '#374151', 
                    fontWeight: '600',
                    display: 'block',
                    marginBottom: '6px'
                  }}>
                    Bet Type:
                  </label>
                  <select 
                    value={betForm.betType}
                    onChange={(e) => setBetForm({...betForm, betType: e.target.value as 'increase' | 'decrease'})}
                    style={{
                      width: '100%',
                      padding: '8px',
                      border: '1px solid #d1d5db',
                      borderRadius: '6px',
                      fontSize: '14px',
                      backgroundColor: 'white',
                      color: '#1f2937'
                    }}
                  >
                    <option value="increase">Portfolio Increase</option>
                    <option value="decrease">Portfolio Decrease</option>
                  </select>
                </div>

                {/* Target Percentage */}
                <div>
                  <label style={{ 
                    fontSize: '14px', 
                    color: '#374151', 
                    fontWeight: '600',
                    display: 'block',
                    marginBottom: '6px'
                  }}>
                    Target % ({getDifficultyLabel(betForm.targetPercentage)}):
                  </label>
                  <input 
                    type="number" 
                    value={betForm.targetPercentage}
                    onChange={(e) => setBetForm({...betForm, targetPercentage: parseFloat(e.target.value) || 1})}
                    min="1"
                    max="100"
                    style={{
                      width: '100%',
                      padding: '8px',
                      border: '1px solid #d1d5db',
                      borderRadius: '6px',
                      fontSize: '14px',
                      backgroundColor: 'white',
                      color: '#1f2937'
                    }}
                  />
                </div>

                {/* Bet Amount */}
                <div>
                  <label style={{ 
                    fontSize: '14px', 
                    color: '#374151', 
                    fontWeight: '600',
                    display: 'block',
                    marginBottom: '6px'
                  }}>
                    Bet Amount ($):
                  </label>
                  <input 
                    type="number" 
                    value={betForm.amount}
                    onChange={(e) => setBetForm({...betForm, amount: parseFloat(e.target.value) || 0})}
                    min="1"
                    max={currentUser.balance}
                    style={{
                      width: '100%',
                      padding: '8px',
                      border: '1px solid #d1d5db',
                      borderRadius: '6px',
                      fontSize: '14px',
                      backgroundColor: 'white',
                      color: '#1f2937'
                    }}
                  />
                </div>

                {/* Time Frame */}
                <div>
                  <label style={{ 
                    fontSize: '14px', 
                    color: '#374151', 
                    fontWeight: '600',
                    display: 'block',
                    marginBottom: '6px'
                  }}>
                    Time Frame (days):
                  </label>
                  <input 
                    type="number" 
                    value={betForm.timeFrame}
                    onChange={(e) => setBetForm({...betForm, timeFrame: parseFloat(e.target.value) || 1})}
                    min="1"
                    max="365"
                    style={{
                      width: '100%',
                      padding: '8px',
                      border: '1px solid #d1d5db',
                      borderRadius: '6px',
                      fontSize: '14px',
                      backgroundColor: 'white',
                      color: '#1f2937'
                    }}
                  />
                </div>
              </div>

              {/* Bet Calculation Display */}
              <div style={{
                padding: '12px',
                backgroundColor: '#f9fafb',
                borderRadius: '6px',
                border: '1px solid #e5e7eb',
                marginBottom: '15px'
              }}>
                <div style={{ fontSize: '14px', color: '#374151', marginBottom: '8px' }}>
                  <strong>Bet Summary:</strong>
                </div>
                <div style={{ fontSize: '13px', color: '#6b7280', lineHeight: '1.4' }}>
                  Target: {targetUserData.username}'s portfolio will <strong>{betForm.betType}</strong> by <strong>{betForm.targetPercentage}%</strong> within <strong>{betForm.timeFrame} days</strong><br/>
                  Risk Level: <strong>{getVolatilityRating(betForm.targetPercentage)}</strong> ({getDifficultyLabel(betForm.targetPercentage)})<br/>
                  Multiplier: <strong>{calculateBetMultiplier(betForm.betType, betForm.targetPercentage, betForm.timeFrame, targetUserData.volatility, targetUserData.recentPerformance)}x</strong><br/>
                  Potential Payout: <strong>${Math.round(betForm.amount * calculateBetMultiplier(betForm.betType, betForm.targetPercentage, betForm.timeFrame, targetUserData.volatility, targetUserData.recentPerformance))}</strong>
                </div>
              </div>

              {/* Place Bet Button */}
              <button 
                onClick={handlePlaceBet}
                disabled={betForm.amount <= 0 || betForm.amount > currentUser.balance}
                style={{
                  width: '100%',
                  padding: '12px',
                  backgroundColor: (betForm.amount <= 0 || betForm.amount > currentUser.balance) ? '#9ca3af' : '#8b5cf6',
                  color: 'white',
                  border: 'none',
                  borderRadius: '8px',
                  cursor: (betForm.amount <= 0 || betForm.amount > currentUser.balance) ? 'not-allowed' : 'pointer',
                  fontSize: '16px',
                  fontWeight: '700',
                  transition: 'all 0.2s ease'
                }}
                              >
                  {betForm.amount <= 0 ? 'Enter Bet Amount' :
                   betForm.amount > currentUser.balance ? 'Insufficient Funds' :
                   `Place Bet ($${betForm.amount})`}
                </button>
            </div>
          )}

          {/* Message Display */}
          {message && (
            <div style={{
              padding: '10px',
              borderRadius: 'var(--radius-lg)',
              marginBottom: '15px',
              backgroundColor: message.includes('placed') ? '#f0fdf4' : message.includes('cannot') ? '#fef3c7' : '#fef2f2',
              border: `1px solid ${message.includes('placed') ? '#bbf7d0' : message.includes('cannot') ? '#fde68a' : '#fecaca'}`,
              color: message.includes('placed') ? '#166534' : message.includes('cannot') ? '#92400e' : '#dc2626',
              fontSize: '13px',
              fontWeight: '600'
            }}>
              {message}
            </div>
          )}

          {/* Bottom Section - Context Dependent */}
          {isIdeaRelated() && activity.opinionText && (
            <div>
              {/* Price Display */}
              <div style={{
                padding: '15px',
                backgroundColor: 'var(--bg-card)',
                borderRadius: 'var(--radius-lg)',
                border: '2px solid var(--border-primary)',
                marginBottom: '15px'
              }}>
                <h4 style={{ 
                  margin: '0 0 5px 0', 
                  fontSize: '16px',
                  color: 'var(--text-primary)'
                }}>
                  Current Price: ${currentPrice.toFixed(2)}
                </h4>
                <p style={{ 
                  margin: 0, 
                  fontSize: '12px', 
                  color: 'var(--text-secondary)',
                  lineHeight: '1.3'
                }}>
                  "{activity.opinionText.slice(0, 60)}..."
                </p>
                {alreadyOwned && (
                  <p style={{ 
                    margin: '5px 0 0 0', 
                    fontSize: '12px', 
                    color: 'var(--lime-green)',
                    fontWeight: '600'
                  }}>
                    You own {ownedQuantity} shares â€¢ Sell price: ${calculateSellPrice(currentPrice).toFixed(2)}
                  </p>
                )}
              </div>

              {/* Trading Interface */}
              <div style={{
                display: 'flex',
                gap: '10px',
                marginBottom: '15px'
              }}>
                {/* Buy Section */}
                <div style={{
                  flex: 1,
                  padding: '15px',
                  backgroundColor: 'white',
                  borderRadius: 'var(--radius-lg)',
                  border: '2px solid var(--border-primary)',
                  boxShadow: '0 2px 4px rgba(0,0,0,0.1)'
                }}>
                  <h5 style={{ 
                    margin: '0 0 12px 0', 
                    fontSize: '16px',
                    color: '#1f2937',
                    fontWeight: '700'
                  }}>
                    Buy Shares
                  </h5>
                  
                  {/* Rapid Trading Warning */}
                  {(() => {
                    const rapidTradeCount = getRapidTradeCount(activity.opinionText || '', 10);
                    const isAtLimit = rapidTradeCount >= 3;
                    const isNearLimit = rapidTradeCount >= 2;
                    
                    if (rapidTradeCount > 0) {
                      return (
                        <div style={{
                          padding: '8px',
                          backgroundColor: isAtLimit ? '#fef2f2' : isNearLimit ? '#fef3c7' : '#f0f9ff',
                          border: `1px solid ${isAtLimit ? '#fecaca' : isNearLimit ? '#fde68a' : '#bfdbfe'}`,
                          borderRadius: '6px',
                          marginBottom: '10px',
                          fontSize: '12px',
                          color: isAtLimit ? '#dc2626' : isNearLimit ? '#92400e' : '#1d4ed8',
                          fontWeight: '700',
                          textAlign: 'center'
                        }}>
                          {isAtLimit ? 
                            'TRADING LIMIT REACHED (3/3)' : 
                            `TRADING WARNING: ${rapidTradeCount}/3 purchases in 10 minutes`
                          }
                          <div style={{ fontSize: '10px', marginTop: '2px', fontWeight: '500' }}>
                            {isAtLimit ? 
                              'Wait 10 minutes from your first purchase to buy more' :
                              `${3 - rapidTradeCount} more purchases allowed in this 10-minute window`
                            }
                          </div>
                        </div>
                      );
                    }
                    return null;
                  })()}
                  
                  <div style={{
                    display: 'flex',
                    alignItems: 'center',
                    gap: '8px',
                    marginBottom: '12px'
                  }}>
                    <span style={{ fontSize: '14px', color: '#374151', fontWeight: '600' }}>Quantity:</span>
                    <button 
                      onClick={() => setQuantity(Math.max(1, quantity - 1))}
                      disabled={quantity <= 1}
                      style={{
                        width: '30px',
                        height: '30px',
                        border: '2px solid #d1d5db',
                        backgroundColor: quantity <= 1 ? '#f3f4f6' : '#ffffff',
                        cursor: quantity <= 1 ? 'not-allowed' : 'pointer',
                        borderRadius: '6px',
                        fontSize: '14px',
                        fontWeight: '700',
                        color: '#374151'
                      }}
                    >
                      -
                    </button>
                    <span style={{ 
                      minWidth: '30px', 
                      textAlign: 'center',
                      fontSize: '16px',
                      fontWeight: '700',
                      color: '#1f2937'
                    }}>
                      {quantity}
                    </span>
                    <button 
                      onClick={() => setQuantity(quantity + 1)}
                      disabled={currentPrice * (quantity + 1) > currentUser.balance}
                      style={{
                        width: '30px',
                        height: '30px',
                        border: '2px solid #d1d5db',
                        backgroundColor: currentPrice * (quantity + 1) > currentUser.balance ? '#f3f4f6' : '#ffffff',
                        cursor: currentPrice * (quantity + 1) > currentUser.balance ? 'not-allowed' : 'pointer',
                        borderRadius: '6px',
                        fontSize: '14px',
                        fontWeight: '700',
                        color: '#374151'
                      }}
                    >
                      +
                    </button>
                  </div>
                  <div style={{ 
                    fontSize: '14px', 
                    color: '#374151',
                    marginBottom: '12px',
                    fontWeight: '600'
                  }}>
                    Total Cost: ${(currentPrice * quantity).toFixed(2)}
                  </div>
                  <button 
                    onClick={handleBuy}
                    disabled={currentPrice * quantity > currentUser.balance || getRapidTradeCount(activity.opinionText || '', 10) >= 3}
                    style={{
                      width: '100%',
                      padding: '12px',
                      backgroundColor: (() => {
                        const rapidCount = getRapidTradeCount(activity.opinionText || '', 10);
                        if (rapidCount >= 3) return '#dc2626';
                        if (currentPrice * quantity > currentUser.balance) return '#9ca3af';
                        return '#f3f4f6'; // Grey background
                      })(),
                      color: (() => {
                        const rapidCount = getRapidTradeCount(activity.opinionText || '', 10);
                        if (rapidCount >= 3 || currentPrice * quantity > currentUser.balance) return 'white';
                        return '#374151'; // Dark grey text
                      })(),
                      border: '2px solid #000000', // Black outline
                      borderRadius: '8px',
                      cursor: (currentPrice * quantity > currentUser.balance || getRapidTradeCount(activity.opinionText || '', 10) >= 3) ? 'not-allowed' : 'pointer',
                      fontSize: '14px',
                      fontWeight: '700',
                      transition: 'all 0.2s ease'
                    }}
                    onMouseEnter={(e) => {
                      const rapidCount = getRapidTradeCount(activity.opinionText || '', 10);
                      if (!(currentPrice * quantity > currentUser.balance || rapidCount >= 3)) {
                        e.currentTarget.style.backgroundColor = '#10b981'; // Green hover
                        e.currentTarget.style.color = 'white';
                      }
                    }}
                    onMouseLeave={(e) => {
                      const rapidCount = getRapidTradeCount(activity.opinionText || '', 10);
                      if (!(currentPrice * quantity > currentUser.balance || rapidCount >= 3)) {
                        e.currentTarget.style.backgroundColor = '#f3f4f6'; // Back to grey
                        e.currentTarget.style.color = '#374151'; // Back to dark grey text
                      }
                    }}
                  >
                    {(() => {
                      const rapidCount = getRapidTradeCount(activity.opinionText || '', 10);
                      if (rapidCount >= 3) return 'TRADING LIMIT REACHED';
                      if (currentPrice * quantity > currentUser.balance) return 'INSUFFICIENT FUNDS';
                      return `Buy ${quantity} Share${quantity !== 1 ? 's' : ''} ($${(currentPrice * quantity).toFixed(2)})`;
                    })()}
                  </button>
                  
                  {/* Sell Button */}
                  {alreadyOwned && (
                    <button 
                      onClick={handleSell}
                      style={{
                        width: '100%',
                        padding: '10px',
                        backgroundColor: '#f3f4f6', // Grey background
                        color: '#374151', // Dark grey text
                        border: '2px solid #000000', // Black outline
                        borderRadius: '6px',
                        cursor: 'pointer',
                        fontSize: '14px',
                        fontWeight: '700',
                        marginTop: '8px',
                        transition: 'all 0.2s ease'
                      }}
                      onMouseEnter={(e) => {
                        e.currentTarget.style.backgroundColor = '#ef4444'; // Red hover
                        e.currentTarget.style.color = 'white';
                      }}
                      onMouseLeave={(e) => {
                        e.currentTarget.style.backgroundColor = '#f3f4f6'; // Back to grey
                        e.currentTarget.style.color = '#374151'; // Back to dark grey text
                      }}
                    >
                      Sell 1 Share (${calculateSellPrice(currentPrice).toFixed(2)})
                    </button>
                  )}
                </div>

                {/* Short Section */}
                <div style={{
                  flex: 1,
                  padding: '15px',
                  backgroundColor: 'white',
                  borderRadius: 'var(--radius-lg)',
                  border: '2px solid var(--border-primary)',
                  boxShadow: '0 2px 4px rgba(0,0,0,0.1)'
                }}>
                  <h5 style={{ 
                    margin: '0 0 12px 0', 
                    fontSize: '16px',
                    color: '#1f2937',
                    fontWeight: '700'
                  }}>
                    Short Position
                  </h5>
                  
                  {/* Bet Amount */}
                  <div style={{ marginBottom: '8px' }}>
                    <label style={{ 
                      fontSize: '12px', 
                      color: '#374151', 
                      fontWeight: '600',
                      display: 'block',
                      marginBottom: '4px'
                    }}>
                      Bet Amount ($):
                    </label>
                    <input 
                      type="number" 
                      value={shortSettings.betAmount}
                      onChange={(e) => setShortSettings({...shortSettings, betAmount: parseFloat(e.target.value) || 0})}
                      min="1"
                      max={currentUser.balance}
                      style={{
                        width: '100%',
                        padding: '6px',
                        border: '1px solid #d1d5db',
                        borderRadius: '4px',
                        fontSize: '12px',
                        backgroundColor: 'white',
                        color: '#1f2937'
                      }}
                    />
                  </div>

                  {/* Target Drop % */}
                  <div style={{ marginBottom: '8px' }}>
                    <label style={{ 
                      fontSize: '12px', 
                      color: '#374151', 
                      fontWeight: '600',
                      display: 'block',
                      marginBottom: '4px'
                    }}>
                      Target Drop (%):
                    </label>
                    <input 
                      type="number" 
                      value={shortSettings.targetDropPercentage}
                      onChange={(e) => setShortSettings({...shortSettings, targetDropPercentage: parseFloat(e.target.value) || 0})}
                      min="1"
                      max="100"
                      style={{
                        width: '100%',
                        padding: '6px',
                        border: '1px solid #d1d5db',
                        borderRadius: '4px',
                        fontSize: '12px',
                        backgroundColor: 'white',
                        color: '#1f2937'
                      }}
                    />
                  </div>

                  {/* Time Limit */}
                  <div style={{ marginBottom: '8px' }}>
                    <label style={{ 
                      fontSize: '12px', 
                      color: '#374151', 
                      fontWeight: '600',
                      display: 'block',
                      marginBottom: '4px'
                    }}>
                      Time Limit (hours):
                    </label>
                    <input 
                      type="number" 
                      value={shortSettings.timeLimit}
                      onChange={(e) => setShortSettings({...shortSettings, timeLimit: parseFloat(e.target.value) || 0})}
                      min="1"
                      max="168"
                      style={{
                        width: '100%',
                        padding: '6px',
                        border: '1px solid #d1d5db',
                        borderRadius: '4px',
                        fontSize: '12px',
                        backgroundColor: 'white',
                        color: '#1f2937'
                      }}
                    />
                  </div>

                  {/* Potential Winnings */}
                  <div style={{ 
                    fontSize: '12px', 
                    color: '#374151',
                    marginBottom: '10px',
                    fontWeight: '600'
                  }}>
                    Potential Win: ${calculateShortWinnings(shortSettings.betAmount, shortSettings.targetDropPercentage, shortSettings.timeLimit).toFixed(2)}
                  </div>

                  {/* Short Button */}
                  <button 
                    onClick={handleShort}
                    disabled={shortSettings.betAmount > currentUser.balance || hasActiveShort || ownedQuantity > 0 || shortSettings.betAmount <= 0}
                    style={{
                      width: '100%',
                      padding: '10px',
                      backgroundColor: (shortSettings.betAmount > currentUser.balance || hasActiveShort || ownedQuantity > 0 || shortSettings.betAmount <= 0) ? '#9ca3af' : '#f3f4f6', // Grey background
                      color: (shortSettings.betAmount > currentUser.balance || hasActiveShort || ownedQuantity > 0 || shortSettings.betAmount <= 0) ? 'white' : '#374151', // Dark grey text
                      border: '2px solid #000000', // Black outline
                      borderRadius: '6px',
                      cursor: (shortSettings.betAmount > currentUser.balance || hasActiveShort || ownedQuantity > 0 || shortSettings.betAmount <= 0) ? 'not-allowed' : 'pointer',
                      fontSize: '12px',
                      fontWeight: '700',
                      transition: 'all 0.2s ease'
                    }}
                    onMouseEnter={(e) => {
                      const isDisabled = shortSettings.betAmount > currentUser.balance || hasActiveShort || ownedQuantity > 0 || shortSettings.betAmount <= 0;
                      if (!isDisabled) {
                        e.currentTarget.style.backgroundColor = '#ef4444'; // Red hover
                        e.currentTarget.style.color = 'white';
                      }
                    }}
                    onMouseLeave={(e) => {
                      const isDisabled = shortSettings.betAmount > currentUser.balance || hasActiveShort || ownedQuantity > 0 || shortSettings.betAmount <= 0;
                      if (!isDisabled) {
                        e.currentTarget.style.backgroundColor = '#f3f4f6'; // Back to grey
                        e.currentTarget.style.color = '#374151'; // Back to dark grey text
                      }
                    }}
                  >
                    {hasActiveShort ? 'Active Short Exists' : 
                     ownedQuantity > 0 ? 'Own Shares - Cannot Short' : 
                     shortSettings.betAmount > currentUser.balance ? 'Insufficient Funds' : 
                     shortSettings.betAmount <= 0 ? 'Enter Bet Amount' :
                     `Place Short Bet (${shortSettings.betAmount.toFixed(2)})`}
                  </button>
                </div>
              </div>
            </div>
          )}

          {isPortfolioBet() && activity.targetUser && (
            <div style={{
              padding: '20px',
              backgroundColor: 'var(--bg-card)',
              borderRadius: 'var(--radius-lg)',
              border: '2px solid var(--border-primary)',
              textAlign: 'center',
              marginBottom: '15px'
            }}>
              <h4 style={{ 
                margin: '0 0 15px 0',
                color: 'var(--text-primary)'
              }}>
                Portfolio Bet Target
              </h4>
              <p style={{ 
                margin: '0 0 15px 0',
                color: 'var(--text-secondary)',
                fontSize: '14px'
              }}>
                This bet involves <strong>{activity.targetUser}</strong>'s portfolio performance.
              </p>
              {activity.betType && activity.targetPercentage && (
                <p style={{ 
                  margin: '0 0 20px 0',
                  color: 'var(--text-primary)',
                  fontSize: '14px'
                }}>
                  Prediction: Portfolio will <strong>{activity.betType}</strong> by <strong>{activity.targetPercentage}%</strong>
                  {activity.timeframe && ` within ${activity.timeframe} days`}
                </p>
              )}
              <button 
                onClick={handleViewTargetProfile}
                className="nav-button"
                style={{ 
                  backgroundColor: 'var(--soft-purple)',
                  color: 'white',
                  textDecoration: 'none',
                  display: 'inline-block'
                }}
              >
                View {activity.targetUser}'s Portfolio
              </button>
            </div>
          )}

          {/* Portfolio Betting Button - Moved from User Profile Section */}
          {targetUserData && !targetUserData.isCurrentUser && (
            <div style={{
              marginTop: '15px',
              padding: '12px',
              backgroundColor: 'var(--bg-elevated)',
              borderRadius: 'var(--radius-lg)',
              textAlign: 'center',
              border: '2px solid var(--border-primary)'
            }}>
              <button
                onClick={() => setShowBettingInterface(!showBettingInterface)}
                style={{
                  width: '100%',
                  padding: '12px',
                  backgroundColor: showBettingInterface ? '#ef4444' : '#8b5cf6',
                  color: 'white',
                  border: 'none',
                  borderRadius: '8px',
                  cursor: 'pointer',
                  fontSize: '16px',
                  fontWeight: '700',
                  transition: 'all 0.2s ease'
                }}
                              >
                  {showBettingInterface ? 'Cancel Bet' : 'Bet on Portfolio'}
                </button>
            </div>
          )}
        </div>
      </div>
    </div>
  );
};

export default function FeedPage() {
  const router = useRouter();
  const { user, userProfile: authUserProfile } = useAuth();
  const [activityFeed, setActivityFeed] = useState<ActivityFeedItem[]>([]);
  const [opinions, setOpinions] = useState<{ id: string; text: string }[]>([]);
  const [currentUser, setCurrentUser] = useState<UserProfile>({
    username: 'Loading...', // Will be updated with actual username
    balance: 10000
  });
  const [filter, setFilter] = useState<'all' | 'trades' | 'bets' | 'generates' | 'shorts'>('all');
  const [lastRefresh, setLastRefresh] = useState(Date.now());
  const [selectedTransaction, setSelectedTransaction] = useState<TransactionDetail | null>(null);
  const [showTransactionModal, setShowTransactionModal] = useState(false);
  const [isClient, setIsClient] = useState(false);
  
  // Firebase-specific state
  const [firebaseActivities, setFirebaseActivities] = useState<LocalActivityItem[]>([]);
  const [isLoadingFirebase, setIsLoadingFirebase] = useState(true);
  const [firebaseError, setFirebaseError] = useState<string | null>(null);

  // NEW: Activity detail modal states
  const [showActivityDetailModal, setShowActivityDetailModal] = useState(false);
  const [selectedActivity, setSelectedActivity] = useState<ActivityFeedItem | null>(null);

  // REAL-TIME FEED: Live update state and refs
  const [liveConnectionStatus, setLiveConnectionStatus] = useState<'connecting' | 'connected' | 'disconnected'>('connecting');
  const [newActivityCount, setNewActivityCount] = useState(0);
  const feedContainerRef = useRef<HTMLDivElement>(null);
  const realTimeFeedManager = useRef<RealTimeFeedManager | null>(null);
  const [isAtTop, setIsAtTop] = useState(true);
  
  // Load user profile from Firebase/auth context with localStorage fallback
  useEffect(() => {
    const loadUserProfile = async () => {
      try {
        // First try to get profile from Firebase via realtimeDataService
        const firebaseProfile = await realtimeDataService.getUserProfile();
        
        if (firebaseProfile && user) {
          console.log('Feed page: Using Firebase user profile');
          const finalProfile = {
            username: firebaseProfile.username,
            balance: firebaseProfile.balance || 10000
          };
          
          setCurrentUser(finalProfile);
          
          // CRITICAL: Update the global activity tracker immediately
          if (typeof window !== 'undefined' && (window as any).globalActivityTracker) {
            (window as any).globalActivityTracker.setCurrentUser(finalProfile);
          }
          
          // Update localStorage to ensure consistency
          localStorage.setItem('userProfile', JSON.stringify({
            username: finalProfile.username,
            balance: finalProfile.balance,
            joinDate: firebaseProfile.joinDate ? new Date(firebaseProfile.joinDate).toLocaleDateString() : new Date().toLocaleDateString(),
            totalEarnings: firebaseProfile.totalEarnings || 0,
            totalLosses: firebaseProfile.totalLosses || 0
          }));
          
          return;
        }
        
        // Fallback to auth context + localStorage
        const storedProfile = safeGetFromStorage('userProfile', null);
        
        if (authUserProfile && user) {
          console.log('Feed page: Using authenticated user profile');
          let finalProfile = {
            username: authUserProfile.username,
            balance: authUserProfile.balance
          };
          
          // Override with localStorage balance if available (transactions update localStorage)
          if (storedProfile) {
            finalProfile = {
              ...finalProfile,
              balance: storedProfile.balance || finalProfile.balance
            };
            
            // AUTO-SYNC: If local username is different from authenticated username, fix it immediately
            if (storedProfile.username !== authUserProfile.username) {
              console.log(`ðŸ”§ FEED AUTO-SYNC: Fixing username mismatch: ${storedProfile.username} â†’ ${authUserProfile.username}`);
              
              // Sync username everywhere
              syncUsernameInTransactions(authUserProfile.username);
            }
          }
          
          setCurrentUser(finalProfile);
          
          // CRITICAL: Update the global activity tracker immediately
          if (typeof window !== 'undefined' && (window as any).globalActivityTracker) {
            (window as any).globalActivityTracker.setCurrentUser(finalProfile);
          }
          
          // Update localStorage to ensure consistency
          localStorage.setItem('userProfile', JSON.stringify({
            username: finalProfile.username,
            balance: finalProfile.balance,
            joinDate: authUserProfile.joinDate ? new Date(authUserProfile.joinDate).toLocaleDateString() : new Date().toLocaleDateString(),
            totalEarnings: authUserProfile.totalEarnings || 0,
            totalLosses: authUserProfile.totalLosses || 0
          }));
        
      } else if (user) {
        console.log('Feed page: New authenticated user, checking localStorage first');
        
        if (storedProfile) {
          // Use authenticated email as username if available, prioritize AndyMoney
          let authenticatedUsername = user.email?.split('@')[0] || 'AndyMoney';
          if (user?.email?.includes('andy') || authenticatedUsername === 'OpinionTrader123') {
            authenticatedUsername = 'AndyMoney';
            console.log(`ðŸ”§ ANDY SPECIAL: Using AndyMoney based on email or bad username`);
          }
          const finalProfile = {
            ...storedProfile,
            username: authenticatedUsername // Always use authenticated username
          };
          
          // Auto-sync if username changed
          if (storedProfile.username !== authenticatedUsername) {
            console.log(`ðŸ”§ FEED AUTO-SYNC: Fixing username for new auth user: ${storedProfile.username} â†’ ${authenticatedUsername}`);
            syncUsernameInTransactions(authenticatedUsername);
          }
          
          setCurrentUser(finalProfile);
          
          // Update global activity tracker
          if (typeof window !== 'undefined' && (window as any).globalActivityTracker) {
            (window as any).globalActivityTracker.setCurrentUser(finalProfile);
          }
        } else {
          const newProfile = {
            username: user.email?.split('@')[0] || 'NewTrader',
            balance: 10000
          };
          setCurrentUser(newProfile);
          
          // Update global activity tracker
          if (typeof window !== 'undefined' && (window as any).globalActivityTracker) {
            (window as any).globalActivityTracker.setCurrentUser(newProfile);
          }
        }
      } else {
        // Fallback to localStorage profile (for development/testing)
        if (storedProfile) {
          setCurrentUser(storedProfile);
          
          // Update global activity tracker
          if (typeof window !== 'undefined' && (window as any).globalActivityTracker) {
            (window as any).globalActivityTracker.setCurrentUser(storedProfile);
          }
        }
      }
    } catch (error) {
      console.error('Error loading user profile:', error);
      // Fallback to localStorage profile
      const storedProfile = JSON.parse(localStorage.getItem('userProfile') || '{}');
      if (storedProfile.username) {
        setCurrentUser(storedProfile);
      }
    }
    };

    loadUserProfile();
  }, [authUserProfile?.username, user?.uid]);

  // USERNAME SYNC FUNCTION - ensures consistency across all transactions
  const syncUsernameInTransactions = (newUsername: string) => {
    if (typeof window === 'undefined') return;
    
    try {
      // Update all existing transactions with new username
      const transactions = JSON.parse(localStorage.getItem('transactions') || '[]');
      const updatedTransactions = transactions.map((transaction: any) => {
        if (transaction.username === 'OpinionTrader123' || transaction.username === 'Loading...' || !transaction.username) {
          return { ...transaction, username: newUsername };
        }
        return transaction;
      });
      localStorage.setItem('transactions', JSON.stringify(updatedTransactions));
      
      // Update activity feed
      const activityFeed = JSON.parse(localStorage.getItem('activityFeed') || '[]');
      const updatedActivityFeed = activityFeed.map((activity: any) => {
        if (activity.username === 'OpinionTrader123' || activity.username === 'Loading...' || !activity.username) {
          return { ...activity, username: newUsername };
        }
        return activity;
      });
      localStorage.setItem('activityFeed', JSON.stringify(updatedActivityFeed));
      
      console.log('âœ… Username synced across all transactions and activities');
      
    } catch (error) {
      console.error('Error syncing username:', error);
    }
  };
  
  // Monitor for username changes and sync
  useEffect(() => {
    if (currentUser.username && currentUser.username !== 'Loading...' && currentUser.username !== 'OpinionTrader123') {
      syncUsernameInTransactions(currentUser.username);
    }
  }, [currentUser.username]);

  // UNIFIED TRANSACTION PROCESSING - Complete Implementation
  // Safe localStorage helpers with proper error handling
  const safeGetFromStorage = (key: string, defaultValue: any = null) => {
    if (typeof window === 'undefined') return defaultValue;
    try {
      const item = localStorage.getItem(key);
      return item ? JSON.parse(item) : defaultValue;
    } catch (error) {
      console.error(`Error reading localStorage key ${key}:`, error);
      return defaultValue;
    }
  };

  const safeSetToStorage = (key: string, value: any) => {
    if (typeof window === 'undefined') return;
    try {
      localStorage.setItem(key, JSON.stringify(value));
    } catch (error) {
      console.error(`Error writing to localStorage key ${key}:`, error);
    }
  };

  // UNIFIED: Bot username mapping
  const getBotUsernames = (): { [botId: string]: string } => {
    if (!isClient) return {};
    
    try {
      const bots = safeGetFromStorage('autonomousBots', []);
      const botMap: { [botId: string]: string } = {};
      
      console.log(`ðŸ” DEBUG: Raw bot data from localStorage:`, bots.slice(0, 3));
      
      bots.forEach((bot: any) => {
        if (bot && bot.id && bot.username) {
          botMap[bot.id] = bot.username;
        }
      });
      
      console.log(`ðŸ¤– UNIFIED: Loaded ${Object.keys(botMap).length} bot usernames:`, Object.values(botMap).slice(0, 10));
      console.log(`ðŸ” DEBUG: Sample bot IDs:`, Object.keys(botMap).slice(0, 5));
      return botMap;
    } catch (error) {
      console.error('UNIFIED: Error loading bot usernames:', error);
      return {};
    }
  };

  // UNIFIED: Enhanced bot detection
  const isBot = (username: string): boolean => {
    const botMap = getBotUsernames();
    const botUsernames = Object.values(botMap);
    
    return botUsernames.includes(username) || 
           username.includes('Bot') || 
           username.includes('Alpha') ||
           username.includes('Beta') ||
           username.includes('Gamma') ||
           username.includes('Delta') ||
           username.includes('Sigma') ||
           username.includes('Prime') ||
           username.includes('The') ||
           username.includes('Contrarian') ||
           username.includes('Trend') ||
           username.includes('Value') ||
           username.includes('Day') ||
           username.includes('Whale') ||
           username.includes('Gambler') ||
           username.includes('Scalper') ||
           username.includes('HODLer') ||
           username.includes('Swing') ||
           username.includes('Arbitrageur');
  };

  // UNIFIED: Get relative time
  const getRelativeTime = (timestamp: string): string => {
    try {
      const now = new Date();
      const time = new Date(timestamp);
      const diffInSeconds = Math.floor((now.getTime() - time.getTime()) / 1000);

      if (diffInSeconds < 60) return `${diffInSeconds}s ago`;
      if (diffInSeconds < 3600) return `${Math.floor(diffInSeconds / 60)}m ago`;
      if (diffInSeconds < 86400) return `${Math.floor(diffInSeconds / 3600)}h ago`;
      return `${Math.floor(diffInSeconds / 86400)}d ago`;
    } catch {
      return 'Unknown time';
    }
  };

  // UNIFIED: Price calculation with 0.1% movements
  const calculatePrice = (timesPurchased: number, timesSold: number, basePrice: number = 10.00): number => {
    const netDemand = timesPurchased - timesSold;
    
    let priceMultiplier;
    if (netDemand >= 0) {
      // EXACT: 1.001 = 0.1% increase per purchase (NO volatility multiplier)
      priceMultiplier = Math.pow(1.001, netDemand);
    } else {
      // EXACT: 0.999 = 0.1% decrease per sale (NO volatility multiplier)
      priceMultiplier = Math.max(0.1, Math.pow(0.999, Math.abs(netDemand)));
    }
    
    const calculatedPrice = Math.max(basePrice * 0.5, basePrice * priceMultiplier);
    
    // CRITICAL: Always return exactly 2 decimal places
    return Math.round(calculatedPrice * 100) / 100;
  };

  // UNIFIED: Get current price for an opinion
  const getCurrentPrice = (opinionText: string): number => {
    if (!isClient) return 10.00;
    
    try {
      const marketData = safeGetFromStorage('opinionMarketData', {});
      if (marketData[opinionText]) {
        const price = marketData[opinionText].currentPrice;
        return Math.round(price * 100) / 100;
      }
      return 10.00;
    } catch (error) {
      console.error('UNIFIED: Error getting current price:', error);
      return 10.00;
    }
  };

  // Activity filtering functions
  const filterActivities = (activities: ActivityFeedItem[]): ActivityFeedItem[] => {
    switch (filter) {
      case 'trades':
        return activities.filter(a => ['buy', 'sell'].includes(a.type));
      case 'bets':
        return activities.filter(a => a.type.includes('bet'));
      case 'shorts':
        return activities.filter(a => a.type.includes('short'));
      case 'generates':
        return activities.filter(a => ['generate', 'earn'].includes(a.type));
      default:
        return activities;
    }
  };

  const getFilterCount = (filterType: string): number => {
    switch (filterType) {
      case 'all':
        return activityFeed.length;
      case 'trades':
        return activityFeed.filter(a => ['buy', 'sell'].includes(a.type)).length;
      case 'bets':
        return activityFeed.filter(a => a.type.includes('bet')).length;
      case 'shorts':
        return activityFeed.filter(a => a.type.includes('short')).length;
      case 'generates':
        return activityFeed.filter(a => ['generate', 'earn'].includes(a.type)).length;
      default:
        return 0;
    }
  };

  // Event handlers
  const handleActivityClick = (activity: ActivityFeedItem, event: React.MouseEvent) => {
    // Don't open modal if username was clicked
    if ((event.target as HTMLElement).closest('.clickableUsername')) {
      return;
    }
    
    setSelectedActivity(activity);
    setShowActivityDetailModal(true);
  };

  const handleUsernameClick = (username: string, event: React.MouseEvent) => {
    event.stopPropagation();
    router.push(`/users/${username}`);
  };

  const handleTransactionClick = (activity: ActivityFeedItem) => {
    // Convert activity to transaction detail format
    const transaction: TransactionDetail = {
      ...activity,
      fullDescription: formatActivityDescription(activity)
    };
    setSelectedTransaction(transaction);
    setShowTransactionModal(true);
  };

  // FIREBASE HELPERS: Functions for combining Firebase and local data
  const getLocalBotActivities = (): ActivityFeedItem[] => {
    if (!isClient) return [];
    
    try {
      // Get bot transactions from localStorage as fallback
      const botTransactions = safeGetFromStorage('botTransactions', []);
      const botMap = getBotUsernames();
      const activities: ActivityFeedItem[] = [];
      
      botTransactions.forEach((transaction: any, index: number) => {
        try {
          const uniqueId = transaction.id || `local_bot_${Date.now()}_${index}`;
          let botName = 'Unknown Bot';
          
          if (transaction.botId && botMap[transaction.botId]) {
            botName = botMap[transaction.botId];
          } else if (transaction.botId) {
            botName = `Bot_${transaction.botId.slice(-6)}`;
          }

          let timestamp: string;
          try {
            const parsedDate = new Date(transaction.date || new Date());
            timestamp = !isNaN(parsedDate.getTime()) ? parsedDate.toISOString() : new Date().toISOString();
          } catch {
            timestamp = new Date().toISOString();
          }

          activities.push({
            id: uniqueId,
            type: transaction.type,
            username: botName,
            opinionText: transaction.opinionText,
            opinionId: transaction.opinionId,
            amount: parseFloat(transaction.amount) || 0,
            price: transaction.metadata?.purchasePricePerShare || transaction.metadata?.price,
            quantity: transaction.metadata?.quantity || 1,
            timestamp: timestamp,
            relativeTime: getRelativeTime(timestamp),
            isBot: true
          });
        } catch (error) {
          console.error('Error processing local bot transaction:', error);
        }
      });
      
      return activities;
    } catch (error) {
      console.error('Error getting local bot activities:', error);
      return [];
    }
  };

  // UNIFIED TRANSACTION PROCESSOR (MAIN)
  const unifiedTransactionProcessor = (): ActivityFeedItem[] => {
    console.log('ðŸ”„ UNIFIED: Starting transaction processor...');
    console.log('ðŸ”„ UNIFIED: isClient =', isClient);
    
    if (!isClient) {
      console.log('âŒ UNIFIED: Not client-side, returning empty array');
      return [];
    }
    
    console.log('ðŸ”„ UNIFIED: Processing all transactions with hybrid processor...');
    
    const activities: ActivityFeedItem[] = [];
    const seenIds = new Set<string>();
    const botMap = getBotUsernames();
    
    console.log('ðŸ”„ UNIFIED: Bot map loaded with', Object.keys(botMap).length, 'entries');
    
    try {
      // STEP 1: Process bot transactions with enhanced handling
      const botTransactions = safeGetFromStorage('botTransactions', []);
      console.log(`ðŸ¤– UNIFIED: Processing ${botTransactions.length} bot transactions`);
      console.log(`ðŸ” DEBUG: Sample bot transactions:`, botTransactions.slice(0, 3));
      console.log(`ðŸ” DEBUG: Bot map has ${Object.keys(botMap).length} entries`);
      
      // Enhanced debugging for bot transactions
      if (botTransactions.length > 0) {
        const botIds = [...new Set(botTransactions.map((t: any) => t.botId))].filter(Boolean) as string[];
        console.log(`ðŸ” DEBUG: Bot transaction IDs found:`, botIds.slice(0, 10));
        const botUsernames = botIds.map(id => botMap[id]).filter(Boolean);
        console.log(`ðŸ” DEBUG: Bot usernames mapped:`, botUsernames.slice(0, 10));
      } else {
        console.log(`âš ï¸ DEBUG: No bot transactions found!`);
      }
      
      let botTransactionsProcessed = 0;
      let botTransactionsSkipped = 0;

      botTransactions.forEach((transaction: any, index: number) => {
        try {
          // Generate unique ID with better collision prevention
          const uniqueId = transaction.id || `bot_${transaction.botId}_${Date.now()}_${index}_${Math.random().toString(36).substr(2, 9)}`;
          
          // Skip if we've already seen this ID
          if (seenIds.has(uniqueId)) {
            console.log(`âš ï¸ UNIFIED: Duplicate transaction ID skipped: ${uniqueId}`);
            botTransactionsSkipped++;
            return;
          }
          seenIds.add(uniqueId);

          // Get actual bot name with fallback
          let botName = 'Unknown Bot';
          if (transaction.botId && botMap[transaction.botId]) {
            botName = botMap[transaction.botId];
          } else if (transaction.botId) {
            botName = `Bot_${transaction.botId.slice(-6)}`;
            console.log(`ðŸ” DEBUG: Bot ID ${transaction.botId} not found in map, using fallback: ${botName}`);
          } else {
            console.log(`ðŸ” DEBUG: No botId found in transaction:`, transaction);
          }

          // Extract transaction data
          let activityType = transaction.type;
          let amount = parseFloat(transaction.amount) || 0;
          
          // Extract actual price and quantity from metadata with better fallbacks
          let actualPrice: number | undefined;
          let actualQuantity: number | undefined;
          
          if (transaction.metadata && typeof transaction.metadata === 'object') {
            actualPrice = transaction.metadata.purchasePricePerShare || transaction.metadata.price;
            actualQuantity = transaction.metadata.quantity;
            
            if (actualPrice) {
              console.log(`ðŸ’° UNIFIED: Extracted price from metadata: ${botName} - ${actualPrice.toFixed(2)} x ${actualQuantity || 1}`);
            }
          }
          
          // Calculate proper price if not in metadata - NEVER allow $0.00
          if (!actualPrice && (transaction.type === 'buy' || transaction.type === 'sell')) {
            if (transaction.opinionText) {
              const marketData = safeGetFromStorage('opinionMarketData', {});
              if (marketData[transaction.opinionText]) {
                actualPrice = marketData[transaction.opinionText].currentPrice;
                console.log(`ðŸ’¡ UNIFIED: Using market price for ${transaction.opinionText}: ${actualPrice?.toFixed(2)}`);
              } else {
                // Calculate price based on purchase history
                const allBotTx = botTransactions.filter((tx: any) => tx.opinionText === transaction.opinionText);
                const purchases = allBotTx.filter((tx: any) => tx.type === 'buy').length;
                const sales = allBotTx.filter((tx: any) => tx.type === 'sell').length;
                actualPrice = calculatePrice(purchases, sales, 10.00);
                console.log(`ðŸ”§ UNIFIED: Calculated price for ${transaction.opinionText}: ${actualPrice.toFixed(2)} (${purchases} buys, ${sales} sells)`);
              }
              
              if (!actualQuantity) {
                actualQuantity = Math.max(1, Math.round(Math.abs(amount) / (actualPrice ?? 10.00)));
              }
            } else {
              actualPrice = Math.max(10.00, Math.abs(amount));
              actualQuantity = 1;
              console.log(`âš ï¸ UNIFIED: Fallback pricing for ${botName}: ${actualPrice.toFixed(2)} x 1`);
            }
          }
          
          // Ensure prices are never $0.00
          if (actualPrice && actualPrice < 0.01) {
            actualPrice = 10.00;
            console.log(`ðŸ”§ UNIFIED: Fixed $0.00 price for ${botName} - reset to $10.00`);
          }
          
          // Normalize transaction types and amounts
          switch (transaction.type) {
            case 'bet':
              activityType = 'bet_place';
              amount = -Math.abs(amount);
              break;
            case 'buy':
              activityType = 'buy';
              amount = -Math.abs(amount);
              break;
            case 'sell':
              activityType = 'sell';
              amount = Math.abs(amount);
              break;
            case 'generate':
              activityType = 'generate';
              amount = 0; // FIXED: Generating opinions should be free, not rewarded
              break;
            case 'earn':
              activityType = 'earn';
              amount = Math.abs(amount); // Only legitimate earnings (from trading wins, etc.)
              break;
            case 'short_place':
              activityType = 'short_place';
              amount = -Math.abs(amount);
              break;
            case 'short_win':
              activityType = 'short_win';
              amount = Math.abs(amount);
              break;
            case 'short_loss':
              activityType = 'short_loss';
              amount = -Math.abs(amount);
              break;
          }

          // Parse timestamp with multiple format support
          let timestamp: string;
          if (transaction.date) {
            try {
              let parsedDate: Date;
              
              if (typeof transaction.date === 'string') {
                if (transaction.date.includes('T')) {
                  parsedDate = new Date(transaction.date);
                } else {
                  parsedDate = new Date(transaction.date);
                }
              } else {
                parsedDate = new Date(transaction.date);
              }

              if (!isNaN(parsedDate.getTime())) {
                timestamp = parsedDate.toISOString();
              } else {
                timestamp = new Date().toISOString();
                console.log(`âš ï¸ UNIFIED: Invalid date for transaction ${uniqueId}, using current time`);
              }
            } catch (error) {
              timestamp = new Date().toISOString();
              console.log(`âš ï¸ UNIFIED: Date parsing error for transaction ${uniqueId}:`, error);
            }
          } else {
            timestamp = new Date().toISOString();
          }

          const newActivity: ActivityFeedItem = {
            id: uniqueId,
            type: activityType as any,
            username: botName,
            opinionText: transaction.opinionText,
            opinionId: transaction.opinionId,
            amount: amount,
            price: actualPrice ? Math.round(actualPrice * 100) / 100 : undefined,
            quantity: actualQuantity,
            timestamp: timestamp,
            relativeTime: getRelativeTime(timestamp),
            isBot: true
          };

          activities.push(newActivity);
          botTransactionsProcessed++;

          // Debug log for verification
          if (actualPrice && (transaction.type === 'buy' || transaction.type === 'sell')) {
            console.log(`ðŸ¤–ðŸ’° UNIFIED: Processed: ${botName} - ${activityType} - ${actualQuantity}x @ ${actualPrice.toFixed(2)} = ${Math.abs(amount).toFixed(2)}`);
          }

        } catch (error) {
          console.error(`UNIFIED: Error processing bot transaction ${index}:`, error, transaction);
          botTransactionsSkipped++;
        }
      });

      console.log(`âœ… UNIFIED: Bot transactions: ${botTransactionsProcessed} processed, ${botTransactionsSkipped} skipped`);

      // STEP 2: Process user transactions - SKIP LOCAL TRANSACTIONS
      // NOTE: Local transactions only contain current user's activity
      // All user activity should be in globalActivityFeed instead
      console.log(`ðŸ‘¤ UNIFIED: Skipping local transactions (only current user's data)`);
      
      // Only process local transactions for current user if not in global feed
      try {
        const userTransactions = safeGetFromStorage('transactions', []);
        console.log(`ðŸ‘¤ UNIFIED: Found ${userTransactions.length} local transactions for current user`);
        
        let userTransactionsProcessed = 0;

        userTransactions.forEach((t: any, index: number) => {
          try {
            const uniqueId = t.id || `user_${Date.now()}_${index}_${Math.random().toString(36).substr(2, 9)}`;
            
            if (seenIds.has(uniqueId)) return;
            seenIds.add(uniqueId);

            let timestamp: string;
            try {
              const parsedDate = new Date(t.date || new Date());
              timestamp = !isNaN(parsedDate.getTime()) ? parsedDate.toISOString() : new Date().toISOString();
            } catch {
              timestamp = new Date().toISOString();
            }

            activities.push({
              id: uniqueId,
              type: t.type,
              username: t.username || currentUser.username, // Use actual username from transaction
              opinionText: t.opinionText || t.description?.replace(/^(Bought|Sold|Generated) /, ''),
              opinionId: t.opinionId,
              amount: parseFloat(t.amount) || 0,
              price: t.price ? Math.round(t.price * 100) / 100 : undefined,
              quantity: t.quantity,
              timestamp: timestamp,
              relativeTime: getRelativeTime(timestamp),
              isBot: isBot(t.username || currentUser.username) // Check if it's a bot username
            });

            userTransactionsProcessed++;
          } catch (error) {
            console.error(`UNIFIED: Error processing user transaction ${index}:`, error);
          }
        });

        console.log(`âœ… UNIFIED: Local transactions: ${userTransactionsProcessed} processed`);
      } catch (error) {
        console.error('UNIFIED: Error loading local transactions:', error);
      }

      // STEP 3: Process global activity feed - ENHANCED DEBUGGING
      try {
        const globalFeed = safeGetFromStorage('globalActivityFeed', []);
        console.log(`ðŸŒ UNIFIED: Processing ${globalFeed.length} global feed entries`);
        
        // Enhanced debugging for global feed
        if (globalFeed.length > 0) {
          console.log(`ðŸ” UNIFIED: Sample global feed entries:`, globalFeed.slice(0, 3));
          const usernames = [...new Set(globalFeed.map((a: any) => a.username))];
          console.log(`ðŸ” UNIFIED: Global feed usernames:`, usernames.slice(0, 10));
        } else {
          console.log(`âš ï¸ UNIFIED: Global activity feed is EMPTY! This is likely the issue.`);
        }
        
        let globalEntriesProcessed = 0;

        globalFeed.forEach((activity: any) => {
          try {
            if (seenIds.has(activity.id)) return;
            seenIds.add(activity.id);

            activities.push({
              ...activity,
              isBot: isBot(activity.username),
              relativeTime: getRelativeTime(activity.timestamp),
              amount: typeof activity.amount === 'number' ? Math.round(activity.amount * 100) / 100 : activity.amount,
              price: activity.price ? Math.round(activity.price * 100) / 100 : activity.price
            });

            globalEntriesProcessed++;
          } catch (error) {
            console.error('UNIFIED: Error processing global feed entry:', error);
          }
        });

        console.log(`âœ… UNIFIED: Global feed: ${globalEntriesProcessed} processed`);
      } catch (error) {
        console.error('UNIFIED: Error loading global activity feed:', error);
      }
      
      // STEP 4: Handle empty feed with bot system diagnostics
      if (activities.length === 0) {
        console.log('ðŸ“ UNIFIED: No real activity found - checking bot system status...');
        
        if (typeof window !== 'undefined' && (window as any).botSystem) {
          const botSystem = (window as any).botSystem;
          const isRunning = botSystem.isSystemRunning();
          console.log(`ðŸ¤– UNIFIED: Bot system status: ${isRunning ? 'RUNNING' : 'STOPPED'}`);
          
          if (!isRunning) {
            console.log('âš ï¸ UNIFIED: Bot system is stopped! Attempting to start...');
            try {
              botSystem.startBots();
              console.log('âœ… UNIFIED: Bot system start command sent');
            } catch (error) {
              console.error('âŒ UNIFIED: Failed to start bot system:', error);
            }
          } else {
            console.log('ðŸ¤– UNIFIED: Bot system running but no transactions found - forcing activity...');
            try {
              botSystem.forceBotActivity(5);
              console.log('âœ… UNIFIED: Forced bot activity command sent');
            } catch (error) {
              console.error('âŒ UNIFIED: Failed to force bot activity:', error);
            }
          }
        } else {
          console.log('âŒ UNIFIED: Bot system not found in window object');
        }

        // Add helpful system message
        activities.push({
          id: 'system_message',
          type: 'generate',
          username: 'System',
          opinionText: 'Bot system initializing... If this persists, click "Start Bots" above.',
          amount: 0,
          timestamp: new Date().toISOString(),
          relativeTime: 'just now',
          isBot: false
        });
      }

    } catch (error) {
      console.error('âŒ UNIFIED: Error in transaction processing:', error);
    }

    // STEP 5: Sort, deduplicate, and return results
    const uniqueActivities = activities
      .filter((activity, index, self) => {
        const isDuplicate = self.findIndex(a => 
          a.id === activity.id || 
          (a.username === activity.username && 
           a.type === activity.type && 
           a.amount === activity.amount && 
           Math.abs(new Date(a.timestamp).getTime() - new Date(activity.timestamp).getTime()) < 1000)
        ) !== index;
        
        return !isDuplicate;
      })
      .sort((a, b) => {
        try {
          const timeA = new Date(a.timestamp).getTime();
          const timeB = new Date(b.timestamp).getTime();
          
          // Handle invalid timestamps
          if (isNaN(timeA) && isNaN(timeB)) return 0;
          if (isNaN(timeA)) return 1; // Move invalid timestamps to end
          if (isNaN(timeB)) return -1; // Move invalid timestamps to end
          
          return timeB - timeA; // Newest first
        } catch (error) {
          console.error('Error sorting activities by timestamp:', error);
          return 0;
        }
      })
      .slice(0, 200);

    // Enhanced logging for diagnostics
    const botActivities = uniqueActivities.filter(a => a.isBot);
    const userActivities = uniqueActivities.filter(a => !a.isBot);
    const activityBreakdown = uniqueActivities.reduce((acc, a) => {
      acc[a.type] = (acc[a.type] || 0) + 1;
      return acc;
    }, {} as Record<string, number>);

    console.log(`ðŸ“Š UNIFIED: Final result - ${uniqueActivities.length} unique activities`);
    console.log(`   ðŸ¤– Bot activities: ${botActivities.length}`);
    console.log(`   ðŸ‘¤ User activities: ${userActivities.length}`);
    console.log(`   ðŸ“ˆ Activity breakdown:`, activityBreakdown);
    console.log(`   ðŸ”— Unique bot usernames:`, [...new Set(botActivities.map(a => a.username))].slice(0, 10));
    
    return uniqueActivities;
  } catch (error) {
    console.error('UNIFIED: Error in transaction processor:', error);
    return [];
  }
};

  // Helper functions for UI rendering
  const getActivityIcon = (type: string): React.ReactNode => {
    switch (type) {
      case 'buy':
        return <CurrencyDollar color="white" size={24} style={{ background: 'none', border: 'none', borderRadius: 0, boxShadow: 'none' }} />;
      case 'sell':
        return <HandPeace color="white" size={24} style={{ background: 'none', border: 'none', borderRadius: 0, boxShadow: 'none' }} />;
      case 'bet':
      case 'bet_place':
      case 'bet_win':
      case 'bet_loss':
        return <DiceSix color="white" size={24} style={{ background: 'none', border: 'none', borderRadius: 0, boxShadow: 'none' }} />;
      case 'short_place':
      case 'short_win':
      case 'short_loss':
        return <ChartLineDown color="white" size={24} style={{ background: 'none', border: 'none', borderRadius: 0, boxShadow: 'none' }} />;
      case 'earn':
      case 'generate':
        return <Plus size={24} />;
      default:
        return '\ud83d\udcca';
    }
  };

  const getActivityIconClass = (type: string): string => {
    switch (type) {
      case 'buy': return styles.buyIcon;
      case 'sell': return styles.sellIcon;
      case 'bet':
      case 'bet_place': return styles.betIcon;
      case 'bet_win': return styles.winIcon;
      case 'bet_loss': return styles.lossIcon;
      case 'earn':
      case 'generate': return styles.earnIcon;
      case 'short_place': return styles.shortIcon;
      case 'short_win': return styles.shortWinIcon;
      case 'short_loss': return styles.shortLossIcon;
      default: return styles.defaultIcon;
    }
  };

  const getAmountClass = (amount: number): string => {
    return amount >= 0 ? styles.positiveAmount : styles.negativeAmount;
  };

  const formatActivityDescription = (activity: ActivityFeedItem): string => {
    const { type, username, opinionText, targetUser, betType, targetPercentage, isBot, quantity } = activity;
    const userPrefix = isBot ? 'Bot' : 'User';
    
    switch (type) {
      case 'buy':
        return `${userPrefix} ${username} bought ${quantity || 1} shares of "${opinionText?.slice(0, 40)}..."`;
      case 'sell':
        return `${userPrefix} ${username} sold ${quantity || 1} shares of "${opinionText?.slice(0, 40)}..."`;
      case 'generate':
        return `${userPrefix} ${username} generated opinion: "${opinionText?.slice(0, 50)}..."`;
      case 'earn':
        return `${userPrefix} ${username} generated opinion: "${opinionText?.slice(0, 50)}..."`;
      case 'short_place':
        return `${userPrefix} ${username} shorted "${opinionText?.slice(0, 40)}..."`;
      case 'short_win':
        return `${userPrefix} ${username} won short bet on "${opinionText?.slice(0, 40)}..."`;
      case 'short_loss':
        return `${userPrefix} ${username} lost short bet on "${opinionText?.slice(0, 40)}..."`;
      case 'bet':
        return `${userPrefix} ${username} placed a bet`;
      case 'bet_place':
        return `${userPrefix} ${username} bet ${targetUser} portfolio will ${betType} by ${targetPercentage}%`;
      case 'bet_win':
        return `${userPrefix} ${username} won portfolio bet on ${targetUser}`;
      case 'bet_loss':
        return `${userPrefix} ${username} lost portfolio bet on ${targetUser}`;
      default:
        return `${userPrefix} ${username} performed ${type}`;
    }
  };

  const combineActivities = (firebaseActivities: LocalActivityItem[], localBotActivities: ActivityFeedItem[]): ActivityFeedItem[] => {
    // Convert Firebase activities to ActivityFeedItem format
    const firebaseAsActivityItems: ActivityFeedItem[] = firebaseActivities.map(activity => ({
      id: activity.id,
      type: activity.type,
      username: activity.username,
      opinionText: activity.opinionText,
      opinionId: activity.opinionId,
      amount: activity.amount,
      price: activity.price,
      quantity: activity.quantity,
      targetUser: activity.targetUser,
      betType: activity.betType,
      targetPercentage: activity.targetPercentage,
      timeframe: activity.timeframe,
      timestamp: activity.timestamp,
      relativeTime: activity.relativeTime,
      isBot: activity.isBot
    }));

    // FIXED: Also get local user transactions
    const localUserTransactions = safeGetFromStorage('transactions', []);
    const localUserActivities: ActivityFeedItem[] = localUserTransactions.map((t: any, index: number) => {
      const uniqueId = t.id || `local_user_${Date.now()}_${index}_${Math.random().toString(36).substr(2, 9)}`;
      
      let timestamp: string;
      try {
        const parsedDate = new Date(t.timestamp || t.date || new Date());
        timestamp = !isNaN(parsedDate.getTime()) ? parsedDate.toISOString() : new Date().toISOString();
      } catch {
        timestamp = new Date().toISOString();
      }

      return {
        id: uniqueId,
        type: t.type,
        username: t.username || currentUser.username,
        opinionText: t.opinionText || t.description?.replace(/^(Bought|Sold|Generated) /, ''),
        opinionId: t.opinionId,
        amount: parseFloat(t.amount) || 0,
        price: t.price ? Math.round(t.price * 100) / 100 : undefined,
        quantity: t.quantity,
        targetUser: t.targetUser,
        betType: t.betType,
        targetPercentage: t.targetPercentage,
        timeframe: t.timeframe,
        timestamp: timestamp,
        relativeTime: getRelativeTime(timestamp),
        isBot: false // Local user transactions are always from the user, not bots
      };
    });

    // Combine all activities: Firebase + local bots + local user
    const combined = [...firebaseAsActivityItems, ...localBotActivities, ...localUserActivities];
    const seenIds = new Set<string>();
    const seenFingerprints = new Set<string>();
    
    // ENHANCED: Create fingerprint for semantic duplicate detection
    const createFingerprint = (activity: ActivityFeedItem): string => {
      const opinionKey = activity.opinionText?.substring(0, 50) || 'no_opinion';
      const timeWindow = Math.floor(new Date(activity.timestamp).getTime() / 30000); // 30-second windows
      return `${activity.username}_${activity.type}_${Math.round(activity.amount * 100)}_${opinionKey}_${timeWindow}`;
    };
    
    const deduplicated = combined.filter(activity => {
      // Strategy 1: Skip exact ID duplicates
      if (seenIds.has(activity.id)) {
        console.log(`ðŸ” Skipping duplicate ID: ${activity.id}`);
        return false;
      }
      
      // Strategy 2: Skip semantic duplicates using fingerprints
      const fingerprint = createFingerprint(activity);
      if (seenFingerprints.has(fingerprint)) {
        console.log(`ðŸ” Skipping semantic duplicate: ${fingerprint}`);
        return false;
      }
      
      // Strategy 3: Advanced near-duplicate detection
      const hasNearDuplicate = combined.some(other => {
        if (other.id === activity.id) return false;
        
        const sameUser = other.username === activity.username;
        const sameType = other.type === activity.type;
        const sameAmount = Math.abs(other.amount - activity.amount) < 0.01;
        const sameOpinion = other.opinionText === activity.opinionText || 
                           (!other.opinionText && !activity.opinionText);
        const similarTime = Math.abs(new Date(other.timestamp).getTime() - new Date(activity.timestamp).getTime()) < 5000;
        
        return sameUser && sameType && sameAmount && sameOpinion && similarTime;
      });
      
      if (hasNearDuplicate) {
        // Keep the one with more complete data or prefer Firebase over local
        const betterDuplicate = combined.find(other => {
          if (other.id === activity.id) return false;
          
          const sameUser = other.username === activity.username;
          const sameType = other.type === activity.type;
          const sameAmount = Math.abs(other.amount - activity.amount) < 0.01;
          const sameOpinion = other.opinionText === activity.opinionText || 
                             (!other.opinionText && !activity.opinionText);
          const similarTime = Math.abs(new Date(other.timestamp).getTime() - new Date(activity.timestamp).getTime()) < 5000;
          
          if (sameUser && sameType && sameAmount && sameOpinion && similarTime) {
            // Prefer Firebase data over local data
            const otherIsFirebase = !other.id.startsWith('local_') && !other.id.startsWith('bot_');
            const activityIsFirebase = !activity.id.startsWith('local_') && !activity.id.startsWith('bot_');
            
            if (otherIsFirebase && !activityIsFirebase) return true;
            if (!otherIsFirebase && activityIsFirebase) return false;
            
            // If both are same source, prefer one with more complete data
            const otherHasMoreData = (other.price !== undefined ? 1 : 0) + 
                                    (other.quantity !== undefined ? 1 : 0) + 
                                    (other.opinionText ? 1 : 0);
            const activityHasMoreData = (activity.price !== undefined ? 1 : 0) + 
                                       (activity.quantity !== undefined ? 1 : 0) + 
                                       (activity.opinionText ? 1 : 0);
            
            return otherHasMoreData > activityHasMoreData;
          }
          
          return false;
        });
        
        if (betterDuplicate) {
          console.log(`ðŸ” Skipping near-duplicate (better version exists): ${activity.username} ${activity.type}`);
          return false;
        }
      }
      
      // Activity passed all deduplication checks
      seenIds.add(activity.id);
      seenFingerprints.add(fingerprint);
      return true;
    });

    console.log(`ðŸ”— COMBINED: ${firebaseAsActivityItems.length} Firebase + ${localBotActivities.length} bots + ${localUserActivities.length} user = ${deduplicated.length} total`);

    // Sort by timestamp (newest first) with enhanced error handling
    return deduplicated.sort((a, b) => {
      try {
        const timeA = new Date(a.timestamp).getTime();
        const timeB = new Date(b.timestamp).getTime();
        
        // Handle invalid timestamps
        if (isNaN(timeA) && isNaN(timeB)) return 0;
        if (isNaN(timeA)) return 1; // Move invalid timestamps to end
        if (isNaN(timeB)) return -1; // Move invalid timestamps to end
        
        return timeB - timeA; // Newest first
      } catch (error) {
        console.error('Error sorting activities by timestamp:', error);
        return 0;
      }
    });
  };

  // REAL-TIME FEED: Instant activity pushing
  const addToGlobalFeed = async (activity: Omit<ActivityFeedItem, 'id' | 'relativeTime'>) => {
    if (!isClient) return;
    
    console.log(`ðŸ”´ LIVE FEED: Adding new activity to real-time feed: ${activity.username} - ${activity.type}`);
    
    // 1. IMMEDIATELY push to real-time feed manager for instant UI update
    if (realTimeFeedManager.current) {
      realTimeFeedManager.current.pushActivity(activity);
    }
    
    // 2. Add to localStorage for persistence and bot system integration
    const existingFeed = safeGetFromStorage('globalActivityFeed', []);
    const newActivity: ActivityFeedItem = {
      ...activity,
      id: `local_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      relativeTime: getRelativeTime(activity.timestamp)
    };
    const updatedFeed = [newActivity, ...existingFeed].slice(0, 200);
    safeSetToStorage('globalActivityFeed', updatedFeed);
    
    // 3. Dispatch custom events for cross-system communication
    window.dispatchEvent(new CustomEvent('globalActivityUpdate', {
      detail: { activity: newActivity, totalCount: updatedFeed.length }
    }));
    
    window.dispatchEvent(new CustomEvent('newTransaction', {
      detail: newActivity
    }));
    
    // 4. Also add to Firebase for persistence (non-blocking)
    try {
      await firebaseActivityService.addActivity({
        type: activity.type,
        username: activity.username,
        userId: activity.isBot ? undefined : user?.uid,
        opinionText: activity.opinionText,
        opinionId: activity.opinionId,
        amount: activity.amount,
        price: activity.price,
        quantity: activity.quantity,
        targetUser: activity.targetUser,
        betType: activity.betType,
        targetPercentage: activity.targetPercentage,
        timeframe: activity.timeframe,
        isBot: activity.isBot,
        botId: activity.isBot ? (activity as any).botId : undefined,
        metadata: {
          source: activity.isBot ? 'bot_system' : 'web_app',
          userAgent: navigator.userAgent,
          timestamp: activity.timestamp
        }
      });
      
      console.log('âœ… Activity also saved to Firebase');
    } catch (error) {
      console.error('âŒ Failed to save activity to Firebase (but still showing in real-time):', error);
    }
  };

  const forceRefreshFeed = () => {
    console.log('ðŸ”„ Force refresh requested - loading fresh activities...');
    setLastRefresh(Date.now());
    const newActivity = unifiedTransactionProcessor();
    setActivityFeed(newActivity);
  };

  // REAL-TIME FEED: Force live activity generation for testing
  const forceLiveActivity = () => {
    console.log('ðŸ”´ LIVE FEED: Forcing immediate live activity generation...');
    
    // Generate test activities that will appear instantly
    const testActivities = [
      {
        type: 'buy' as const,
        username: 'LiveTrader_' + Math.random().toString(36).substr(2, 4),
        opinionText: 'Hot opinion being traded right now!',
        amount: -(Math.random() * 100 + 50),
        price: Math.random() * 20 + 10,
        quantity: Math.floor(Math.random() * 10) + 1,
        timestamp: new Date().toISOString(),
        isBot: Math.random() > 0.5
      },
      {
        type: 'sell' as const,
        username: 'QuickSeller_' + Math.random().toString(36).substr(2, 4),
        opinionText: 'Cashing out on this trending opinion',
        amount: Math.random() * 80 + 40,
        price: Math.random() * 15 + 8,
        quantity: Math.floor(Math.random() * 5) + 1,
        timestamp: new Date(Date.now() + 1000).toISOString(),
        isBot: Math.random() > 0.3
      },
      {
        type: 'generate' as const,
        username: 'ContentCreator_' + Math.random().toString(36).substr(2, 4),
        opinionText: 'Fresh opinion just generated: ' + ['The market is volatile', 'Tech stocks are overvalued', 'Green energy is the future'][Math.floor(Math.random() * 3)],
        amount: 0,
        timestamp: new Date(Date.now() + 2000).toISOString(),
        isBot: Math.random() > 0.7
      }
    ];
    
    // Push activities using the proper addToGlobalFeed function for full integration
    testActivities.forEach((activity, index) => {
      setTimeout(() => {
        addToGlobalFeed(activity);
      }, index * 500);
    });
    
    // Also force bot activity
    if (typeof window !== 'undefined' && (window as any).forceBotActivity) {
      setTimeout(() => {
        (window as any).forceBotActivity(3);
      }, 1500);
    }
    
    console.log('ðŸ”´ LIVE FEED: Test activities added - you should see them appear instantly!');
  };
  
  // REAL-TIME TEST: Simple test to verify feed updates without refresh
  const testRealTimeFeed = () => {
    console.log('ðŸ§ª TESTING REAL-TIME FEED: Adding test activity...');
    
    const testActivity = {
      type: 'generate' as const,
      username: 'RealTimeTest_' + Math.random().toString(36).substr(2, 4),
      opinionText: 'This is a real-time test - no refresh needed!',
      amount: 0,
      timestamp: new Date().toISOString(),
      isBot: false
    };
    
    // This should appear instantly without any page refresh
    addToGlobalFeed(testActivity);
    
    alert('ðŸ§ª Real-time test activity added!\n\nIf working correctly, you should see the new activity appear at the top of the feed WITHOUT refreshing the page.\n\nLook for: "RealTimeTest_..."');
  };

  const ensureBotsRunning = () => {
    if (typeof window !== 'undefined' && (window as any).botSystem) {
      const botSystem = (window as any).botSystem;
      if (!botSystem.isSystemRunning()) {
        console.log('ðŸ¤– Starting bot system...');
        botSystem.startBots();
      }
    }
  };

  // SIMPLE: Check what's actually in localStorage
  const checkLocalStorageData = () => {
    console.log('ðŸ” SIMPLE CHECK: Raw localStorage data...');
    
    // Check all localStorage keys
    const keys = Object.keys(localStorage);
    console.log('ðŸ”‘ All localStorage keys:', keys);
    
    // Check specific keys
    const checks = [
      'autonomousBots',
      'botTransactions', 
      'transactions',
      'globalActivityFeed',
      'userProfile'
    ];
    
    checks.forEach(key => {
      try {
        const raw = localStorage.getItem(key);
        const parsed = raw ? JSON.parse(raw) : null;
        console.log(`ðŸ“¦ ${key}:`, {
          exists: !!raw,
          length: Array.isArray(parsed) ? parsed.length : 'not array',
          sample: Array.isArray(parsed) ? parsed.slice(0, 2) : parsed
        });
      } catch (error) {
        console.log(`âŒ ${key}: Error parsing -`, error);
      }
    });
    
    // Special focus on user transactions
    const userTransactions = safeGetFromStorage('transactions', []);
    console.log('ðŸ‘¤ USER TRANSACTIONS DETAIL:');
    console.log(`   Count: ${userTransactions.length}`);
    console.log(`   Current username: ${currentUser.username}`);
    if (userTransactions.length > 0) {
      console.log('   Recent transactions:', userTransactions.slice(0, 5));
      const usernames = [...new Set(userTransactions.map((t: any) => t.username))];
      console.log('   Transaction usernames:', usernames);
    }
  };

  // Fix chronological ordering issues
  const fixChronologicalOrder = () => {
    console.log('ðŸ”§ FIXING CHRONOLOGICAL ORDER...');
    
    // Clear all activity data to force fresh start with proper timestamps
    localStorage.removeItem('botTransactions');
    localStorage.removeItem('globalActivityFeed');
    localStorage.removeItem('opinions');
    localStorage.removeItem('opinionMarketData');
    
    console.log('âœ… Cleared all activity data');
    
    // Restart bot system with fresh data
    if (typeof window !== 'undefined' && (window as any).botSystem) {
      (window as any).botSystem.stopBots();
      setTimeout(() => {
        (window as any).botSystem.startBots();
        setTimeout(() => {
          (window as any).forceBotActivity(15);
        }, 2000);
      }, 1000);
    }
    
    // Refresh feed
    setTimeout(() => {
      forceRefreshFeed();
    }, 5000);
    
    console.log('ðŸ”„ System reset complete - timestamps should now be in proper order');
  };

  // DEBUG: Enhanced diagnostic function to check all data sources
  const debugBotSystem = () => {
    console.log('ðŸ” DIAGNOSTIC: Checking bot system status...');
    
    // First check raw localStorage
    checkLocalStorageData();
    
    // Check localStorage data
    const botsData = safeGetFromStorage('autonomousBots', []);
    const botTransactions = safeGetFromStorage('botTransactions', []);
    const userTransactions = safeGetFromStorage('transactions', []);
    const globalFeed = safeGetFromStorage('globalActivityFeed', []);
    
    console.log('ðŸ“Š Complete System Status:');
    console.log(`  - Bots in localStorage: ${botsData.length}`);
    console.log(`  - Bot transactions: ${botTransactions.length}`);
    console.log(`  - User transactions: ${userTransactions.length}`);
    console.log(`  - Global activity feed: ${globalFeed.length}`);
    console.log(`  - Sample bot usernames:`, botsData.slice(0, 5).map((b: any) => b.username));
    
    // Check global bot system
    if (typeof window !== 'undefined' && (window as any).botSystem) {
      console.log(`  - Bot system running: ${(window as any).botSystem.isSystemRunning()}`);
      console.log(`  - Bot count: ${(window as any).botSystem.getBots().length}`);
    }
    
    // Check global feed content
    if (globalFeed.length > 0) {
      const globalUsernames = [...new Set(globalFeed.map((a: any) => a.username))];
      console.log(`  - Global feed usernames:`, globalUsernames.slice(0, 10));
    }
    
    // Check if addToGlobalFeed is working
    console.log('ðŸ§ª Testing addToGlobalFeed...');
    if (typeof window !== 'undefined' && (window as any).addToGlobalFeed) {
      (window as any).addToGlobalFeed({
        type: 'generate',
        username: 'TestUser',
        opinionText: 'Test opinion for debugging',
        amount: 0,
        timestamp: new Date().toISOString(),
        isBot: false
      });
      console.log('âœ… Test activity added to global feed');
    } else {
      console.log('âŒ addToGlobalFeed not found');
    }
    
    // Force refresh feed
    console.log('ðŸ”„ Forcing feed refresh...');
    forceRefreshFeed();
  };

  // FORCE RESET: Reset bot system and regenerate activity
  const forceResetBotSystem = () => {
    console.log('ðŸ”„ FORCE RESET: Resetting entire bot system...');
    
    if (typeof window !== 'undefined' && (window as any).botSystem) {
      // Stop current bot system
      (window as any).botSystem.stopBots();
      
      // Clear localStorage data
      localStorage.removeItem('autonomousBots');
      localStorage.removeItem('botTransactions');
      
      // Restart bot system
      console.log('ðŸš€ Restarting bot system with fresh data...');
      (window as any).botSystem.manualStart();
      
      // Force some immediate activity
      setTimeout(() => {
        console.log('âš¡ Forcing immediate bot activity...');
        (window as any).forceBotActivity(20);
      }, 3000);
      
      // Refresh feed
      setTimeout(() => {
        console.log('ðŸ”„ Refreshing feed with new bot data...');
        forceRefreshFeed();
      }, 5000);
    }
  };

  // ENHANCED: Complete data reconciliation using the new service
  const reconcileAllData = async () => {
    if (!user?.uid) {
      console.error('âŒ User not authenticated, cannot reconcile data');
      return;
    }
    
    console.log('ðŸ”„ RECONCILIATION: Starting complete data reconciliation...');
    
    try {
      const results = await dataReconciliationService.completeReconciliation(user.uid);
      
      console.log('âœ… Reconciliation completed!', results);
      
      // Show user-friendly summary
      const totalMigrated = results.activities.migrated + results.marketData.migrated;
      const totalConflicts = results.activities.conflicts.length + 
                           results.profile.conflicts.length + 
                           results.marketData.conflicts.length;
      
      console.log(`ðŸ“Š RECONCILIATION SUMMARY:
        - Activities migrated: ${results.activities.migrated}
        - Activities skipped: ${results.activities.skipped}
        - Profile updated: ${results.profile.updated}
        - Market data migrated: ${results.marketData.migrated}
        - Total conflicts: ${totalConflicts}`);
      
      // Force refresh the feed after reconciliation
      forceRefreshFeed();
      
      return results;
    } catch (error) {
      console.error('âŒ Complete reconciliation failed:', error);
      throw error;
    }
  };

  // Get reconciliation status
  const getReconciliationStatus = async () => {
    if (!user?.uid) {
      console.error('âŒ User not authenticated, cannot check reconciliation status');
      return null;
    }
    
    try {
      const summary = await dataReconciliationService.getReconciliationSummary(user.uid);
      console.log('ðŸ“Š Reconciliation status:', summary);
      return summary;
    } catch (error) {
      console.error('âŒ Failed to get reconciliation status:', error);
      return null;
    }
  };

  // LEGACY: Migrate localStorage activity to Firebase (kept for backward compatibility)
  const migrateLocalStorageToFirebase = async () => {
    console.log('ðŸ”„ MIGRATION: Starting localStorage to Firebase migration...');
    
    try {
      // Get existing localStorage activities
      const localActivities = unifiedTransactionProcessor();
      
      if (localActivities.length === 0) {
        console.log('âš ï¸ No local activities found to migrate');
        return;
      }
      
      console.log(`ðŸ“¦ Found ${localActivities.length} local activities to migrate`);
      
      // Convert to Firebase format and add to Firebase
      const firebaseActivities = localActivities.map(activity => ({
        type: activity.type,
        username: activity.username,
        userId: activity.username === currentUser.username ? user?.uid : undefined,
        opinionText: activity.opinionText,
        opinionId: activity.opinionId,
        amount: activity.amount,
        price: activity.price,
        quantity: activity.quantity,
        targetUser: activity.targetUser,
        betType: activity.betType,
        targetPercentage: activity.targetPercentage,
        timeframe: activity.timeframe,
        isBot: activity.isBot,
        metadata: {
          source: 'migration',
          originalTimestamp: activity.timestamp,
          migrationDate: new Date().toISOString()
        }
      }));
      
      await firebaseActivityService.addActivitiesBatch(firebaseActivities);
      console.log('âœ… Migration completed successfully!');
      
    } catch (error) {
      console.error('âŒ Migration failed:', error);
    }
  };

  // FIREBASE TEST: Add test activities to Firebase
  const addTestActivitiesToFirebase = async () => {
    console.log('ðŸ§ª TEST: Adding test activities to Firebase...');
    
    const testActivities = [
      {
        type: 'buy' as const,
        username: currentUser.username,
        userId: user?.uid,
        opinionText: 'Test opinion for Firebase integration',
        amount: -50,
        price: 10,
        quantity: 5,
        isBot: false,
        metadata: { source: 'test' }
      },
      {
        type: 'generate' as const,
        username: 'TestBot',
        opinionText: 'Bot-generated test opinion for Firebase',
        amount: 100,
        isBot: true,
        metadata: { source: 'test' }
      },
      {
        type: 'sell' as const,
        username: currentUser.username,
        userId: user?.uid,
        opinionText: 'Another test opinion',
        amount: 45,
        price: 9,
        quantity: 5,
        isBot: false,
        metadata: { source: 'test' }
      }
    ];
    
    try {
      await firebaseActivityService.addActivitiesBatch(testActivities);
      console.log('âœ… Test activities added to Firebase successfully!');
    } catch (error) {
      console.error('âŒ Failed to add test activities:', error);
    }
  };

  // Client-side hydration
  useEffect(() => {
    setIsClient(true);
  }, []);

  // Scroll detection for feed container
  useEffect(() => {
    if (!feedContainerRef.current) return;
    
    const handleScroll = () => {
      if (feedContainerRef.current) {
        const { scrollTop } = feedContainerRef.current;
        setIsAtTop(scrollTop < 50); // Consider "at top" if within 50px
      }
    };
    
    const container = feedContainerRef.current;
    container.addEventListener('scroll', handleScroll);
    
    return () => {
      container.removeEventListener('scroll', handleScroll);
    };
  }, [feedContainerRef.current]);

  // Make functions available globally
  useEffect(() => {
    if (!isClient) return;
    
    (window as any).addToGlobalFeed = addToGlobalFeed;
    (window as any).forceRefreshFeed = forceRefreshFeed;
    (window as any).forceLiveActivity = forceLiveActivity;
    (window as any).testRealTimeFeed = testRealTimeFeed;
    (window as any).debugBotSystem = debugBotSystem;
    (window as any).forceResetBotSystem = forceResetBotSystem;
    (window as any).migrateLocalStorageToFirebase = migrateLocalStorageToFirebase;
    (window as any).addTestActivitiesToFirebase = addTestActivitiesToFirebase;
    (window as any).firebaseActivityService = firebaseActivityService;
    (window as any).fixChronologicalOrder = fixChronologicalOrder;
    (window as any).realTimeFeedManager = realTimeFeedManager.current;
    
    // NEW: Enhanced reconciliation functions
    (window as any).reconcileAllData = reconcileAllData;
    (window as any).getReconciliationStatus = getReconciliationStatus;
    (window as any).dataReconciliationService = dataReconciliationService;
    
    // TEST: Realistic behavior verification
    (window as any).testRealisticBehavior = testRealisticBehavior;
    
    return () => {
      delete (window as any).addToGlobalFeed;
      delete (window as any).forceRefreshFeed;
      delete (window as any).forceLiveActivity;
      delete (window as any).testRealTimeFeed;
      delete (window as any).debugBotSystem;
      delete (window as any).forceResetBotSystem;
      delete (window as any).migrateLocalStorageToFirebase;
      delete (window as any).addTestActivitiesToFirebase;
      delete (window as any).firebaseActivityService;
      delete (window as any).fixChronologicalOrder;
      delete (window as any).realTimeFeedManager;
      delete (window as any).reconcileAllData;
      delete (window as any).getReconciliationStatus;
      delete (window as any).dataReconciliationService;
      delete (window as any).testRealisticBehavior;
    };
  }, [isClient]);

  // Initialize data
  useEffect(() => {
    if (!isClient) return;
    
    // Load opinions
    const stored = safeGetFromStorage('opinions', null);
    if (stored) {
      const parsed = stored;
      const validOpinions = parsed.filter((op: any) => op && typeof op === 'string' && op.trim().length > 0);
      setOpinions(validOpinions.map((text: string, i: number) => ({ id: i.toString(), text })));
    }

    // Load user profile
    const storedProfile = safeGetFromStorage('userProfile', null);
    if (storedProfile) {
      setCurrentUser(storedProfile);
    }

    // Ensure bots are running
    ensureBotsRunning();
    
    // CRITICAL: Sync existing bot transactions to global feed
    if (typeof window !== 'undefined' && (window as any).syncBotTransactionsToGlobalFeed) {
      console.log('ðŸ”„ Auto-syncing bot transactions to global feed...');
      setTimeout(() => {
        (window as any).syncBotTransactionsToGlobalFeed();
      }, 2000); // Wait 2 seconds for systems to initialize
    }
  }, [isClient]);

  // REAL-TIME FEED: Instant activity streaming without refreshes
  const handleNewActivity = useCallback((newActivity: ActivityFeedItem) => {
    console.log(`ðŸ”´ LIVE FEED: Received instant activity: ${newActivity.username} - ${newActivity.type} - ${newActivity.opinionText?.slice(0, 30)}...`);
    
    setActivityFeed(prevFeed => {
      // Check for duplicates
      const existingActivity = prevFeed.find(activity => 
        activity.id === newActivity.id ||
        (activity.username === newActivity.username && 
         activity.type === newActivity.type &&
         Math.abs(new Date(activity.timestamp).getTime() - new Date(newActivity.timestamp).getTime()) < 2000)
      );
      
      if (existingActivity) {
        console.log(`ðŸ”´ LIVE FEED: Duplicate activity detected, skipping`);
        return prevFeed;
      }
      
      // Add new activity to the top
      const updatedFeed = [newActivity, ...prevFeed].slice(0, 200); // Keep only latest 200
      console.log(`âœ… REAL-TIME UPDATE: Activity added to feed! ${newActivity.username} ${newActivity.type} appears instantly (no refresh needed)`);
      console.log(`ðŸ“Š LIVE FEED: Feed now has ${updatedFeed.length} activities`);
      return updatedFeed;
    });
    
    // Update counters
    setNewActivityCount(prev => prev + 1);
    setLastRefresh(Date.now());
    
    // Auto-scroll to top if user is already at top
    if (isAtTop && feedContainerRef.current) {
      setTimeout(() => {
        feedContainerRef.current?.scrollTo({ top: 0, behavior: 'smooth' });
      }, 100);
    }
  }, [isAtTop]);

  // Initialize real-time feed system
  useEffect(() => {
    if (!isClient) return;
    
    console.log('ðŸ”´ LIVE FEED: Initializing real-time feed system...');
    setLiveConnectionStatus('connecting');
    
    // Get the global real-time feed manager
    realTimeFeedManager.current = RealTimeFeedManager.getInstance();
    
    // Subscribe to instant activity updates
    const unsubscribe = realTimeFeedManager.current.subscribe(handleNewActivity);
    
    // Load initial feed data
    setTimeout(() => {
      console.log('ðŸ”´ LIVE FEED: Loading initial feed data...');
      const initialActivity = unifiedTransactionProcessor();
      setActivityFeed(initialActivity);
      setLiveConnectionStatus('connected');
      setLastRefresh(Date.now());
      
      // Start bot system for continuous activity
      if (typeof window !== 'undefined' && (window as any).botSystem) {
        const botSystem = (window as any).botSystem;
        if (!botSystem.isSystemRunning()) {
          botSystem.startBots();
        }
        // Generate some initial activity
        setTimeout(() => {
          if (typeof window !== 'undefined' && (window as any).forceBotActivity) {
            (window as any).forceBotActivity(5);
          }
        }, 2000);
      }
    }, 500);
    
    // CRITICAL: Listen for localStorage changes to trigger real-time updates
    const handleStorageChange = (e: StorageEvent) => {
      if (e.key === 'botTransactions' || e.key === 'globalActivityFeed' || e.key === 'transactions') {
        console.log(`ðŸ”´ LIVE FEED: Storage changed for ${e.key}, triggering real-time update...`);
        
        // Small delay to ensure data is written
        setTimeout(() => {
          const latestActivity = unifiedTransactionProcessor();
          const currentFeedIds = new Set(activityFeed.map(a => a.id));
          
          // Find new activities
          const newActivities = latestActivity.filter(activity => !currentFeedIds.has(activity.id));
          
          if (newActivities.length > 0) {
            console.log(`ðŸ”´ LIVE FEED: Found ${newActivities.length} new activities from storage change`);
            newActivities.forEach(activity => {
              if (realTimeFeedManager.current) {
                realTimeFeedManager.current.pushActivity(activity);
              }
            });
          }
        }, 100);
      }
    };
    
    // CRITICAL: Listen for custom events from bot system and global activity tracker
    const handleGlobalActivityUpdate = (e: CustomEvent) => {
      console.log('ðŸ”´ LIVE FEED: Received global activity update event:', e.detail);
      if (e.detail?.activity && realTimeFeedManager.current) {
        realTimeFeedManager.current.pushActivity(e.detail.activity);
      }
    };
    
    const handleNewTransaction = (e: CustomEvent) => {
      console.log('ðŸ”´ LIVE FEED: Received new transaction event:', e.detail);
      if (e.detail && realTimeFeedManager.current) {
        realTimeFeedManager.current.pushActivity(e.detail);
      }
    };
    
    // Add event listeners
    window.addEventListener('storage', handleStorageChange);
    window.addEventListener('globalActivityUpdate', handleGlobalActivityUpdate as EventListener);
    window.addEventListener('newTransaction', handleNewTransaction as EventListener);
    
    // FALLBACK: Periodic check for new activities (as backup to real-time system)
    const periodicCheck = setInterval(() => {
      const latestActivity = unifiedTransactionProcessor();
      
      // Get current feed state at check time
      setActivityFeed(currentFeed => {
        const currentFeedIds = new Set(currentFeed.map(a => a.id));
        
        // Find new activities
        const newActivities = latestActivity.filter(activity => 
          !currentFeedIds.has(activity.id) && 
          new Date(activity.timestamp).getTime() > (Date.now() - 10000) // Only activities from last 10 seconds
        );
        
        if (newActivities.length > 0) {
          console.log(`ðŸ”´ LIVE FEED: Periodic check found ${newActivities.length} new activities`);
          newActivities.forEach(activity => {
            if (realTimeFeedManager.current) {
              realTimeFeedManager.current.pushActivity(activity);
            }
          });
        }
        
        // Return current feed unchanged (real-time manager handles updates)
        return currentFeed;
      });
    }, 3000); // Check every 3 seconds

    // Firebase real-time integration with error handling
    const firebaseUnsubscribe = firebaseActivityService.subscribeToActivities(
      (firebaseActivities) => {
        console.log(`ðŸ”¥ Firebase: Received ${firebaseActivities.length} activities`);
        setFirebaseActivities(firebaseActivities);
        setIsLoadingFirebase(false);
        setFirebaseError(null);
        
        // Convert Firebase activities and push to real-time feed
        firebaseActivities.forEach(activity => {
          const activityItem: ActivityFeedItem = {
            id: activity.id,
            type: activity.type,
            username: activity.username,
            opinionText: activity.opinionText,
            opinionId: activity.opinionId,
            amount: activity.amount,
            price: activity.price,
            quantity: activity.quantity,
            targetUser: activity.targetUser,
            betType: activity.betType,
            targetPercentage: activity.targetPercentage,
            timeframe: activity.timeframe,
            timestamp: activity.timestamp,
            relativeTime: activity.relativeTime,
            isBot: activity.isBot
          };
          
          // Only push new activities (not initial load)
          const isNew = new Date(activity.timestamp).getTime() > (Date.now() - 10000);
          if (isNew && realTimeFeedManager.current) {
            realTimeFeedManager.current.pushActivity(activityItem);
          }
        });
      },
      200,
      // Error handler for Firebase permissions issues
      (error: Error) => {
        console.error('ðŸ”¥ Firebase subscription error:', error);
        const errorMessage = error.message || 'Firebase connection error';
        setFirebaseError(errorMessage);
        setIsLoadingFirebase(false);
        
        // Check if it's a permissions error
        if (errorMessage.includes('permission') || errorMessage.includes('Missing or insufficient permissions')) {
          console.error('ðŸ”’ Firebase permissions issue detected - falling back to localStorage mode');
          setLiveConnectionStatus('disconnected');
        } else {
          setLiveConnectionStatus('disconnected');
        }
        
        // Fallback to localStorage-only mode
        console.log('âš ï¸ Falling back to localStorage-only mode due to Firebase error...');
        const localActivity = unifiedTransactionProcessor();
        setActivityFeed(localActivity);
        
        // Still show as "connected" for local data, but with Firebase error indicator
        if (!errorMessage.includes('permission')) {
          setLiveConnectionStatus('connected'); // Still connected to local data
        }
      }
    );

    // Relative time updates (less frequent, since we show "just now" for new items)
    const relativeTimeInterval = setInterval(() => {
      setActivityFeed(prevFeed => 
        prevFeed.map(activity => ({
          ...activity,
          relativeTime: getRelativeTime(activity.timestamp)
        }))
      );
    }, 30000); // Update every 30 seconds

    // Connection heartbeat
    const heartbeatInterval = setInterval(() => {
      const subscriberCount = realTimeFeedManager.current?.getSubscriberCount() || 0;
      console.log(`ðŸ’“ LIVE FEED: Heartbeat - ${subscriberCount} subscribers, ${activityFeed.length} activities`);
      
      if (subscriberCount === 0) {
        setLiveConnectionStatus('disconnected');
      } else {
        setLiveConnectionStatus('connected');
      }
    }, 10000);

    return () => {
      console.log('ðŸ”´ LIVE FEED: Cleaning up real-time feed system...');
      unsubscribe();
      firebaseUnsubscribe();
      clearInterval(relativeTimeInterval);
      clearInterval(heartbeatInterval);
      clearInterval(periodicCheck);
      
      // Remove event listeners
      window.removeEventListener('storage', handleStorageChange);
      window.removeEventListener('globalActivityUpdate', handleGlobalActivityUpdate as EventListener);
      window.removeEventListener('newTransaction', handleNewTransaction as EventListener);
      
      setLiveConnectionStatus('disconnected');
    };
  }, [isClient, handleNewActivity]);

  // Don't render until client-side hydration is complete
  if (!isClient) {
    return <div>Loading...</div>;
  }

  const filteredActivities = filterActivities(activityFeed);
  const botActivityCount = activityFeed.filter(a => a.isBot).length;
  const humanActivityCount = activityFeed.filter(a => !a.isBot).length;
  const shortActivityCount = activityFeed.filter(a => a.type.includes('short')).length;

  // TEST: Verify realistic activity behavior
  const testRealisticBehavior = () => {
    console.log('ðŸ§ª TESTING REALISTIC BEHAVIOR...');
    
    // Test generate activity
    const testGenerateActivity = {
      type: 'generate' as const,
      username: 'TestUser',
      opinionText: 'Test generated opinion',
      amount: 100, // This should be normalized to 0
      timestamp: new Date().toISOString(),
      isBot: false
    };
    
    // Add to feed and check if amount is normalized
    if (typeof window !== 'undefined' && (window as any).addToGlobalFeed) {
      (window as any).addToGlobalFeed(testGenerateActivity);
    }
    
    // Test the transaction processor
    const testBotTransaction = {
      type: 'generate',
      botId: 'test_bot',
      opinionText: 'Test bot generated opinion',
      amount: 150,
      date: new Date().toISOString()
    };
    
    // Mock process this transaction
    const processedAmount = testBotTransaction.type === 'generate' ? 0 : testBotTransaction.amount;
    
    console.log('âœ… TEST RESULTS:');
    console.log(`  Generate activity amount: $${processedAmount.toFixed(2)} (should be $0.00)`);
    console.log(`  Generate description: "${formatActivityDescription({
      id: 'test',
      type: 'generate',
      username: 'TestUser',
      opinionText: 'Test opinion',
      amount: 0,
      timestamp: new Date().toISOString(),
      relativeTime: 'now',
      isBot: false
    })}"`);
    
    // Verify buy/sell still work normally
    console.log(`  Buy description: "${formatActivityDescription({
      id: 'test',
      type: 'buy',
      username: 'TestUser',
      opinionText: 'Test opinion',
      amount: -50,
      timestamp: new Date().toISOString(),
      relativeTime: 'now',
      isBot: false
    })}"`);
    
    console.log('ðŸŽ¯ Generate activities should now show $0.00 and correct descriptions!');
  };

  return (
    <div className="page-container" style={{
      display: 'flex',
      minHeight: '100vh',
      backgroundColor: '#F1F0EC',
      fontFamily: "'Noto Sans', 'Inter', -apple-system, BlinkMacSystemFont, sans-serif"
    }}>
      <Sidebar opinions={opinions} />
      
      <main className="main-content" style={{ 
        paddingLeft: '20px', 
        paddingRight: '20px', 
        paddingTop: '115px', 
        flex: 1,
        maxWidth: '1200px',
        margin: '0 auto',
        marginTop: '95px'
      }}>
        {/* Header */}
        <div className="header-section" style={{ 
          backgroundColor: 'white', 
          padding: '16px 20px',
          marginBottom: '20px',
          marginLeft: '-20px',
          paddingLeft: '40px',
          display: 'flex',
          justifyContent: 'flex-start',
          alignItems: 'center',
          gap: '16px',
          position: 'fixed',
          top: 0,
          width: '100%',
          maxWidth: '1200px',
          height: '95px',
          zIndex: 1000
        }}>
          <div className="user-header" style={{
            display: 'flex',
            alignItems: 'center',
            flex: 1,
            maxWidth: '600px'
          }}>
            <div className="user-info">
              <h1 style={{
                fontSize: '36px',
                margin: '0',
                fontWeight: '800',
                color: '#1a1a1a'
              }}>Live Feed</h1>
            </div>
          </div>

          {/* Navigation Buttons */}
          <div className="navigation-buttons" style={{
            display: 'flex',
            gap: '0px',
            flexWrap: 'wrap',
            padding: '24px 0',
            justifyContent: 'flex-start',
            alignItems: 'center'
          }}>
            <a href="/users" className="nav-button">
              <ScanSmiley size={24} /> View Traders
            </a>
            <button className="nav-button">
              <Rss size={24} /> Live Feed
            </button>
            <a href="/generate" className="nav-button">
              <Balloon size={24} /> Generate Opinion
            </a>
            <a href="/profile" className="nav-button">
              <Wallet size={24} /> My Portfolio
            </a>
            <AuthButton />
          </div>
        </div>



                  {/* Firebase Status Indicator */}
          <div style={{
            marginTop: '12px',
            marginBottom: '8px',
            padding: '8px 12px',
            backgroundColor: isLoadingFirebase ? '#fef3c7' : firebaseError ? '#fef2f2' : '#f0fdf4',
            border: `1px solid ${isLoadingFirebase ? '#fde68a' : firebaseError ? '#fecaca' : '#bbf7d0'}`,
            borderRadius: '6px',
            fontSize: '13px',
            fontWeight: '600',
            color: isLoadingFirebase ? '#92400e' : firebaseError ? '#dc2626' : '#166534',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'space-between',
            gap: '8px'
          }}>
            <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
              {isLoadingFirebase ? (
                <>ðŸ”¥ Connecting to Firebase...</>
              ) : firebaseError ? (
                <>âŒ Firebase Error: {firebaseError} (using localStorage fallback)</>
              ) : (
                <>âœ… Firebase Connected â€¢ {firebaseActivities.length} activities â€¢ Real-time updates active</>
              )}
            </div>
            
            {/* Firebase Help Button for Permissions Issues */}
            {firebaseError && firebaseError.includes('permission') && (
              <button
                onClick={() => {
                  const helpText = `ðŸ”’ FIREBASE PERMISSIONS FIX:

1. Go to Firebase Console: https://console.firebase.google.com
2. Select your project: "idea-auction"
3. Click "Firestore Database" in sidebar
4. Click "Rules" tab
5. Replace the rules with:

rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Allow read/write for authenticated users
    match /{document=**} {
      allow read, write: if request.auth != null;
    }
    
    // Temporary: Allow read access to activity-feed for development
    match /activity-feed/{document} {
      allow read: if true;
      allow write: if request.auth != null;
    }
  }
}

6. Click "Publish"
7. Refresh this page

The app is working in localStorage mode for now.`;
                  alert(helpText);
                }}
                style={{
                  padding: '4px 8px',
                  backgroundColor: '#dc2626',
                  color: 'white',
                  border: 'none',
                  borderRadius: '4px',
                  cursor: 'pointer',
                  fontSize: '11px',
                  fontWeight: '600'
                }}
              >
                ðŸ› ï¸ Fix Firebase
              </button>
            )}
          </div>

          {/* Filter Controls */}
        <div className={styles.filterControls} style={{ 
          marginTop: '8px',
          marginBottom: '16px', 
          display: 'flex',
          visibility: 'visible',
          zIndex: 1,
          gap: '8px',
          padding: '1rem',
          backgroundColor: '#F1F0EC',
          borderRadius: '16px',
          border: '1px solid #000000',
          alignItems: 'center'
        }}>
          <span className={styles.filterLabel} style={{
            marginRight: '1rem',
            fontWeight: '700',
            color: '#555555',
            fontSize: '12px',
            textTransform: 'uppercase',
            letterSpacing: '0.5px'
          }}>Filter:</span>
          {(['all', 'trades', 'bets', 'shorts', 'generates'] as const).map(filterType => (
            <button
              key={filterType}
              onClick={() => setFilter(filterType)}
              className={`${styles.filterButton} ${filter === filterType ? styles.active : ''}`}
              style={{
                padding: '8px 16px',
                border: filter === filterType ? '2px solid #3b82f6' : '2px solid #63b3ed',
                borderRadius: '12px',
                cursor: 'pointer',
                fontWeight: '600',
                fontSize: '12px',
                textTransform: 'capitalize',
                background: filter === filterType ? '#3b82f6' : '#F1F0EC',
                color: filter === filterType ? '#ffffff' : '#1a1a1a',
                whiteSpace: 'nowrap',
                fontFamily: 'inherit'
              }}
            >
              {filterType === 'all' ? `All Activity (${getFilterCount(filterType)})` :
               filterType === 'trades' ? `Trades (${getFilterCount(filterType)})` :
               filterType === 'bets' ? `Bets (${getFilterCount(filterType)})` :
               filterType === 'shorts' ? `Shorts (${getFilterCount(filterType)})` :
               `Generates (${getFilterCount(filterType)})`}
            </button>
          ))}
        </div>

        {/* Activity Feed */}
        <div className={styles.feedContainer} style={{
          backgroundColor: '#ffffff',
          borderRadius: '20px',
          border: '1px solid #000000',
          overflow: 'hidden',
          boxShadow: '0 4px 8px rgba(0, 0, 0, 0.1)'
        }}>
          {/* Real-Time Feed Header with Live Connection Status */}
          <div className={styles.feedHeader} style={{
            padding: '1rem 1.5rem',
            backgroundColor: '#F1F0EC',
            borderBottom: '1px solid #000000',
            fontWeight: '700',
            color: '#1a1a1a',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'space-between',
            fontSize: '12px'
          }}>
            <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
              <div className={styles.liveIndicator} style={{
                width: '8px',
                height: '8px',
                backgroundColor: liveConnectionStatus === 'connected' ? '#10b981' : 
                                liveConnectionStatus === 'connecting' ? '#f59e0b' : '#ef4444',
                borderRadius: '50%',
                animation: liveConnectionStatus === 'connected' ? 'pulse 1s infinite' : 
                          liveConnectionStatus === 'connecting' ? 'pulse 0.5s infinite' : 'none'
              }}></div>
              <span style={{ 
                color: liveConnectionStatus === 'connected' ? '#10b981' : 
                       liveConnectionStatus === 'connecting' ? '#f59e0b' : '#ef4444',
                fontWeight: '800' 
              }}>
                {liveConnectionStatus === 'connected' ? 'LIVE' : 
                 liveConnectionStatus === 'connecting' ? 'CONNECTING' : 'DISCONNECTED'}
              </span>
              <span style={{ color: '#666' }}>â€¢</span>
              <span>{filteredActivities.length} Activities</span>
              <span style={{ color: '#666' }}>â€¢</span>
              <span style={{ color: '#10b981' }}>ðŸ¤– {botActivityCount} bots</span>
              <span style={{ color: '#666' }}>â€¢</span>
              <span style={{ color: '#3b82f6' }}>ðŸ‘¤ {humanActivityCount} users</span>
              {newActivityCount > 0 && (
                <>
                  <span style={{ color: '#666' }}>â€¢</span>
                  <span style={{ 
                    backgroundColor: '#10b981', 
                    color: 'white', 
                    padding: '2px 6px', 
                    borderRadius: '4px',
                    fontSize: '10px',
                    animation: 'pulse 1s infinite'
                  }}>
                    +{newActivityCount} NEW
                  </span>
                </>
              )}
            </div>
            
            <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
              <div style={{
                width: '6px',
                height: '6px',
                backgroundColor: liveConnectionStatus === 'connected' ? '#10b981' : '#ef4444',
                borderRadius: '50%',
                animation: liveConnectionStatus === 'connected' ? 'pulse 0.5s infinite' : 'none'
              }}></div>
              <span style={{ 
                color: liveConnectionStatus === 'connected' ? '#10b981' : '#ef4444',
                fontSize: '11px' 
              }}>
                {liveConnectionStatus === 'connected' ? 'Real-time streaming' : 
                 liveConnectionStatus === 'connecting' ? 'Connecting...' : 'Connection lost'}
              </span>
              <span style={{ 
                backgroundColor: liveConnectionStatus === 'connected' ? '#10b981' : '#ef4444',
                color: 'white', 
                padding: '2px 6px', 
                borderRadius: '4px',
                fontSize: '10px'
              }}>
                {liveConnectionStatus === 'connected' ? 'LIVE' : 
                 liveConnectionStatus === 'connecting' ? 'CONNECTING' : 'OFFLINE'}
              </span>
            </div>
          </div>

          {/* Feed Content */}
          <div 
            ref={feedContainerRef}
            className={styles.feedContent} 
            style={{
              maxHeight: '70vh',
              overflowY: 'auto',
              padding: '0',
              backgroundColor: '#ffffff'
            }}
          >
            {/* Scroll to top button */}
            {!isAtTop && (
              <div style={{
                position: 'absolute',
                top: '10px',
                left: '50%',
                transform: 'translateX(-50%)',
                zIndex: 10,
                backgroundColor: '#3b82f6',
                color: 'white',
                padding: '8px 16px',
                borderRadius: '20px',
                fontSize: '12px',
                fontWeight: '600',
                cursor: 'pointer',
                boxShadow: '0 2px 8px rgba(0,0,0,0.15)',
                animation: 'fadeIn 0.3s ease-in-out'
              }}
              onClick={() => {
                feedContainerRef.current?.scrollTo({ top: 0, behavior: 'smooth' });
                setNewActivityCount(0);
              }}
              >
                â†‘ {newActivityCount > 0 ? `${newActivityCount} new activities` : 'Back to top'}
              </div>
            )}
            {filteredActivities.length === 0 ? (
              <div className={styles.emptyFeed}>
                <p>ðŸ“­</p>
                <p>No activity found matching your filter.</p>
                <p style={{ fontSize: '14px', color: '#666', marginTop: '10px' }}>
                  ðŸ¤– Bot system may be starting up. Click "Start Bots" to begin automated trading.
                </p>
                <div style={{ marginTop: '15px', display: 'flex', gap: '10px', justifyContent: 'center', flexWrap: 'wrap' }}>
                  <button 
                    onClick={() => {
                      ensureBotsRunning();
                      setTimeout(forceRefreshFeed, 2000);
                    }}
                    style={{
                      padding: '8px 16px',
                      backgroundColor: '#10b981',
                      color: 'white',
                      border: 'none',
                      borderRadius: '6px',
                      cursor: 'pointer'
                    }}
                  >
                    ðŸ¤– Start Bot System
                  </button>
                  <button 
                    onClick={forceRefreshFeed}
                    style={{
                      padding: '8px 16px',
                      backgroundColor: '#3b82f6',
                      color: 'white',
                      border: 'none',
                      borderRadius: '6px',
                      cursor: 'pointer'
                    }}
                  >
                    ðŸ”„ Refresh Feed
                  </button>
                  <button 
                    onClick={() => {
                      if (typeof window !== 'undefined' && (window as any).forceBotActivity) {
                        (window as any).forceBotActivity(10);
                        setTimeout(forceRefreshFeed, 3000);
                      }
                    }}
                    style={{
                      padding: '8px 16px',
                      backgroundColor: '#f59e0b',
                      color: 'white',
                      border: 'none',
                      borderRadius: '6px',
                      cursor: 'pointer'
                    }}
                  >
                    ðŸš€ Force Bot Activity
                  </button>
                  <button 
                    onClick={debugBotSystem}
                    style={{
                      padding: '8px 16px',
                      backgroundColor: '#8b5cf6',
                      color: 'white',
                      border: 'none',
                      borderRadius: '6px',
                      cursor: 'pointer'
                    }}
                  >
                    ðŸ” Debug System
                  </button>
                  <button 
                    onClick={checkLocalStorageData}
                    style={{
                      padding: '8px 16px',
                      backgroundColor: '#ef4444',
                      color: 'white',
                      border: 'none',
                      borderRadius: '6px',
                      cursor: 'pointer'
                    }}
                  >
                    ðŸ“¦ Check Storage
                  </button>
                  <button 
                    onClick={fixChronologicalOrder}
                    style={{
                      padding: '8px 16px',
                      backgroundColor: '#dc2626',
                      color: 'white',
                      border: 'none',
                      borderRadius: '6px',
                      cursor: 'pointer'
                    }}
                  >
                    ðŸ”§ Fix Timestamps
                  </button>
                  <button 
                    onClick={() => {
                      console.log('ðŸ‘¤ CHECKING USER ACTIVITIES...');
                      const userTransactions = safeGetFromStorage('transactions', []);
                      console.log(`Found ${userTransactions.length} user transactions:`, userTransactions);
                      
                      // Force include user activities in current feed
                      const currentFeed = [...activityFeed];
                      const userActivities = userTransactions.map((t: any, index: number) => ({
                        id: `debug_${Date.now()}_${index}`,
                        type: t.type,
                        username: t.username || currentUser.username,
                        opinionText: t.opinionText,
                        opinionId: t.opinionId,
                        amount: parseFloat(t.amount) || 0,
                        price: t.price,
                        quantity: t.quantity,
                        timestamp: t.timestamp || t.date || new Date().toISOString(),
                        relativeTime: getRelativeTime(t.timestamp || t.date || new Date().toISOString()),
                        isBot: false
                      }));
                      
                      const combinedFeed = [...userActivities, ...currentFeed];
                      setActivityFeed(combinedFeed);
                      console.log(`âœ… Added ${userActivities.length} user activities to feed`);
                    }}
                    style={{
                      padding: '8px 16px',
                      backgroundColor: '#9333ea',
                      color: 'white',
                      border: 'none',
                      borderRadius: '6px',
                      cursor: 'pointer'
                    }}
                  >
                    ðŸ‘¤ Show My Activities
                  </button>
                  <button 
                    onClick={() => {
                      console.log('ðŸ”„ SYNCING BOT TRANSACTIONS...');
                      if (typeof window !== 'undefined' && (window as any).syncBotTransactionsToGlobalFeed) {
                        (window as any).syncBotTransactionsToGlobalFeed();
                        setTimeout(forceRefreshFeed, 1000);
                      } else {
                        console.log('âŒ Sync function not available');
                      }
                    }}
                    style={{
                      padding: '8px 16px',
                      backgroundColor: '#f59e0b',
                      color: 'white',
                      border: 'none',
                      borderRadius: '6px',
                      cursor: 'pointer'
                    }}
                  >
                    ðŸ”„ Sync Bot Transactions
                  </button>
                </div>
                
                {/* Firebase-specific buttons */}
                <div style={{ marginTop: '10px', display: 'flex', gap: '10px', justifyContent: 'center', flexWrap: 'wrap' }}>
                  <button 
                    onClick={migrateLocalStorageToFirebase}
                    style={{
                      padding: '8px 16px',
                      backgroundColor: '#059669',
                      color: 'white',
                      border: 'none',
                      borderRadius: '6px',
                      cursor: 'pointer'
                    }}
                  >
                    ðŸ”¥ Migrate to Firebase
                  </button>
                  <button 
                    onClick={addTestActivitiesToFirebase}
                    style={{
                      padding: '8px 16px',
                      backgroundColor: '#7c3aed',
                      color: 'white',
                      border: 'none',
                      borderRadius: '6px',
                      cursor: 'pointer'
                    }}
                  >
                    ðŸ§ª Add Test Activities
                  </button>
                  <button 
                    onClick={testRealisticBehavior}
                    style={{
                      padding: '8px 16px',
                      backgroundColor: '#22c55e',
                      color: 'white',
                      border: 'none',
                      borderRadius: '6px',
                      cursor: 'pointer'
                    }}
                  >
                    âœ… Test Realistic Behavior
                  </button>
                  <button 
                    onClick={forceLiveActivity}
                    style={{
                      padding: '8px 16px',
                      backgroundColor: '#dc2626',
                      color: 'white',
                      border: 'none',
                      borderRadius: '6px',
                      cursor: 'pointer',
                      fontWeight: '700'
                    }}
                  >
                    ðŸ”´ FORCE LIVE ACTIVITY
                  </button>
                  <button 
                    onClick={testRealTimeFeed}
                    style={{
                      padding: '8px 16px',
                      backgroundColor: '#22c55e',
                      color: 'white',
                      border: 'none',
                      borderRadius: '6px',
                      cursor: 'pointer',
                      fontWeight: '700'
                    }}
                  >
                    âš¡ TEST REAL-TIME FEED
                  </button>
                  <button 
                    onClick={async () => {
                      console.log('ðŸ§ª Testing Firebase connection...');
                      try {
                        // Test Firebase read permissions
                        const testActivities = await firebaseActivityService.getRecentActivities(5);
                        console.log('âœ… Firebase read test successful:', testActivities.length, 'activities');
                        
                        // Test Firebase write permissions (if authenticated)
                        if (user?.uid) {
                          await firebaseActivityService.addActivity({
                            type: 'generate',
                            username: currentUser.username,
                            userId: user.uid,
                            opinionText: 'Firebase connection test - this can be ignored',
                            amount: 0,
                            isBot: false,
                            metadata: { source: 'connection_test' }
                          });
                          console.log('âœ… Firebase write test successful');
                          alert('ðŸŽ‰ Firebase connection test PASSED!\n\nâœ… Read permissions: Working\nâœ… Write permissions: Working\n\nYour Firebase setup is correct!');
                        } else {
                          alert('âœ… Firebase read test PASSED!\n\nâš ï¸ Write test skipped: Not authenticated\n\nFirebase is working! Sign in to test write permissions.');
                        }
                      } catch (error) {
                        console.error('âŒ Firebase connection test failed:', error);
                        const errorMsg = (error as Error).message || 'Unknown error';
                        if (errorMsg.includes('permission')) {
                          alert('âŒ Firebase permissions test FAILED!\n\nðŸ”’ Issue: Missing or insufficient permissions\n\nðŸ› ï¸ Fix:\n1. Go to Firebase Console\n2. Update Firestore security rules\n3. Use the firestore.rules file provided\n4. Click "Publish"\n\nSee FIREBASE_PERMISSIONS_FIX.md for detailed instructions.');
                        } else {
                          alert(`âŒ Firebase test FAILED!\n\nError: ${errorMsg}\n\nCheck the browser console for more details.`);
                        }
                      }
                    }}
                    style={{
                      padding: '8px 16px',
                      backgroundColor: '#0ea5e9',
                      color: 'white',
                      border: 'none',
                      borderRadius: '6px',
                      cursor: 'pointer',
                      fontWeight: '700'
                    }}
                  >
                    ðŸ§ª Test Firebase Connection
                  </button>
                  <button 
                    onClick={async () => {
                      try {
                        console.log('ðŸ” Testing Firebase bot activity write...');
                        await firebaseActivityService.addActivity({
                          type: 'buy',
                          username: 'TestBot_' + Math.random().toString(36).substr(2, 4),
                          opinionText: 'Test Firebase bot connection',
                          amount: 50,
                          price: 15,
                          quantity: 1,
                          isBot: true,
                          botId: 'test-bot-' + Date.now(),
                          metadata: {
                            source: 'bot_system',
                            test: true,
                            timestamp: new Date().toISOString()
                          }
                        });
                        console.log('âœ… Firebase bot test successful!');
                        alert('âœ… Firebase bot test successful!\n\nBot activities can now sync to Firebase.\nCheck the feed for the test bot activity.');
                      } catch (error) {
                        console.error('âŒ Firebase bot test failed:', error);
                        const errorMsg = (error as Error).message || 'Unknown error';
                        alert(`âŒ Firebase bot test failed!\n\nError: ${errorMsg}\n\nThis means bot activities will fall back to localStorage only.\nSee FIREBASE_PERMISSIONS_FIX.md for instructions to fix this.`);
                      }
                    }}
                    style={{
                      padding: '8px 16px',
                      backgroundColor: '#059669',
                      color: 'white',
                      border: 'none',
                      borderRadius: '6px',
                      cursor: 'pointer',
                      fontWeight: '700'
                    }}
                  >
                    ðŸ¤– Test Bot Firebase
                  </button>
                </div>
              </div>
            ) : (
              filteredActivities.map((activity, index) => {
                const isUserActivity = activity.username === currentUser.username;
                const isBotActivity = activity.isBot;
                const isShortActivity = activity.type.includes('short');
                const isNewActivity = activity.relativeTime === 'just now' || activity.id.startsWith('live_');
                
                return (
                  <div 
                    key={activity.id}
                    className={`${styles.activityItem} ${isUserActivity ? styles.userActivity : ''} ${isBotActivity ? styles.botActivity : ''} ${isShortActivity ? styles.shortActivity : ''}`}
                    onClick={(e) => handleActivityClick(activity, e)}
                    style={{ 
                      cursor: 'pointer', 
                      userSelect: 'none',
                      padding: '1rem 1.5rem',
                      borderBottom: '1px solid #000000',
                      backgroundColor: isNewActivity ? '#f0fdf4' : '#ffffff',
                      transition: 'all 200ms ease-out',
                      animation: isNewActivity ? 'slideInFromTop 0.5s ease-out' : 'none',
                      borderLeft: isNewActivity ? '4px solid #10b981' : 'none'
                    }}
                    onMouseEnter={(e) => {
                      e.currentTarget.style.backgroundColor = isNewActivity ? '#ecfdf5' : '#f8fafc';
                      if (!isNewActivity) {
                        e.currentTarget.style.borderLeft = '4px solid #0F7950';
                      }
                    }}
                    onMouseLeave={(e) => {
                      e.currentTarget.style.backgroundColor = isNewActivity ? '#f0fdf4' : '#ffffff';
                      if (!isNewActivity) {
                        e.currentTarget.style.borderLeft = 'none';
                      }
                    }}
                  >
                    <div className={styles.activityLayout} style={{
                      display: 'flex',
                      alignItems: 'center',
                      gap: '1rem'
                    }}>
                      {/* Activity Icon */}
                      {(() => {
                        if (activity.type === 'buy') {
                          return (
                            <div style={{ width: 40, height: 40, display: 'flex', alignItems: 'center', justifyContent: 'center', borderRadius: '50%', background: 'rgba(92,184,92,1)' }}>
                              <CurrencyDollar color="white" size={24} style={{ background: 'none', border: 'none', borderRadius: 0, boxShadow: 'none' }} />
                            </div>
                          );
                        } else if (activity.type === 'sell') {
                          return (
                            <div style={{ width: 40, height: 40, display: 'flex', alignItems: 'center', justifyContent: 'center', borderRadius: '50%', background: 'rgba(239,68,68,1)' }}>
                              <HandPeace color="white" size={24} style={{ background: 'none', border: 'none', borderRadius: 0, boxShadow: 'none' }} />
                            </div>
                          );
                        } else if (["bet", "bet_place", "bet_win", "bet_loss"].includes(activity.type)) {
                          return (
                            <div style={{ width: 40, height: 40, display: 'flex', alignItems: 'center', justifyContent: 'center', borderRadius: '50%', background: 'rgba(255, 118, 2, 1)' }}>
                              <DiceSix color="white" size={24} style={{ background: 'none', border: 'none', borderRadius: 0, boxShadow: 'none' }} />
                            </div>
                          );
                        } else if (["short_place", "short_win", "short_loss"].includes(activity.type)) {
                          return (
                            <div style={{ width: 40, height: 40, display: 'flex', alignItems: 'center', justifyContent: 'center', borderRadius: '50%', background: 'rgba(236,72,153,1)' }}>
                              <ChartLineDown color="white" size={24} style={{ background: 'none', border: 'none', borderRadius: 0, boxShadow: 'none' }} />
                            </div>
                          );
                        } else {
                          return (
                            <div className={`${styles.activityIcon} ${getActivityIconClass(activity.type)}`}>
                              {getActivityIcon(activity.type)}
                            </div>
                          );
                        }
                      })()}

                      {/* Activity Content */}
                      <div className={styles.activityContent} style={{
                        flex: 1
                      }}>
                        <div className={styles.activityDescription} style={{
                          fontSize: '14px',
                          lineHeight: '1.5',
                          color: '#1a1a1a',
                          marginBottom: '4px'
                        }}>
                          {formatActivityDescription(activity)}
                          {isUserActivity && (
                            <span className={styles.userBadge} style={{
                              backgroundColor: '#3b82f6',
                              color: 'white',
                              padding: '2px 8px',
                              borderRadius: '12px',
                              fontSize: '10px',
                              fontWeight: '700',
                              marginLeft: '8px'
                            }}>
                              YOU
                            </span>
                          )}
                          {isBotActivity && (
                            <span className={styles.botBadge} style={{
                              backgroundColor: '#10b981',
                              color: 'white',
                              padding: '2px 8px',
                              borderRadius: '12px',
                              fontSize: '10px',
                              fontWeight: '700',
                              marginLeft: '8px'
                            }}>
                              BOT
                            </span>
                          )}
                          {isShortActivity && (
                            <span className={styles.shortBadge} style={{
                              backgroundColor: '#ec4899',
                              color: 'white',
                              padding: '2px 8px',
                              borderRadius: '12px',
                              fontSize: '10px',
                              fontWeight: '700',
                              marginLeft: '8px'
                            }}>
                              SHORT
                            </span>
                          )}
                          {/* Clickable username */}
                          <span 
                            className="clickableUsername"
                            onClick={(e) => {
                              e.stopPropagation();
                              handleUsernameClick(activity.username, e);
                            }}
                            style={{ 
                              color: isBotActivity ? '#10b981' : '#3b82f6', 
                              cursor: 'pointer',
                              textDecoration: 'underline',
                              marginLeft: '8px',
                              fontSize: '12px',
                              fontWeight: '600'
                            }}
                          >
                            {isBotActivity ? 'ðŸ¤–' : 'ðŸ‘¤'} {activity.username}
                          </span>
                        </div>
                        
                        <div className={styles.activityMeta} style={{
                          display: 'flex',
                          justifyContent: 'space-between',
                          alignItems: 'center',
                          fontSize: '12px',
                          color: '#7a7a7a'
                        }}>
                          <span className={styles.activityTime}>{activity.relativeTime}</span>
                          <span className={`${styles.activityAmount} ${getAmountClass(activity.amount)}`} style={{
                            fontWeight: '700',
                            color: activity.amount >= 0 ? '#0F7950' : '#BB0006'
                          }}>
                            {activity.amount >= 0 ? '+' : ''}${Math.abs(activity.amount).toFixed(2)}
                          </span>
                        </div>
                      </div>
                    </div>
                  </div>
                );
              })
            )}
          </div>
        </div>

        {/* NEW: Enhanced Activity Detail Modal with Portfolio Betting */}
        {showActivityDetailModal && selectedActivity && (
          <ActivityDetailModal
            activity={selectedActivity}
            onClose={() => {
              setShowActivityDetailModal(false);
              setSelectedActivity(null);
            }}
            currentUser={currentUser}
            onUpdateUser={setCurrentUser}
          />
        )}

        {/* Transaction Details Modal - Preserved advanced implementation */}
        {showTransactionModal && selectedTransaction && (
          <div 
            className={styles.modalOverlay}
            onClick={(e) => {
              if (e.target === e.currentTarget) {
                setShowTransactionModal(false);
                setSelectedTransaction(null);
              }
            }}
          >
            <div className={styles.transactionModal}>
              <div className={styles.modalHeader}>
                <h2>
                  {getActivityIcon(selectedTransaction.type)} Transaction Details
                </h2>
                <button
                  onClick={() => {
                    setShowTransactionModal(false);
                    setSelectedTransaction(null);
                  }}
                  className={styles.closeButton}
                >
                  âœ•
                </button>
              </div>

              <div className={styles.modalContent}>
                {/* Transaction Type & User */}
                <div className={styles.transactionHeader}>
                  <div className={styles.transactionType}>
                    <span className={`${styles.typeTag} ${styles[selectedTransaction.type]}`}>
                      {selectedTransaction.type.toUpperCase().replace('_', ' ')}
                    </span>
                    {selectedTransaction.isBot && (
                      <span className={styles.botTag}>ðŸ¤– BOT</span>
                    )}
                    {selectedTransaction.type.includes('short') && (
                      <span className={styles.shortTag}>ðŸ“‰ SHORT</span>
                    )}
                  </div>
                  <div className={styles.transactionAmount}>
                    <span className={getAmountClass(selectedTransaction.amount)}>
                      {selectedTransaction.amount >= 0 ? '+' : ''}${Math.abs(selectedTransaction.amount).toFixed(2)}
                    </span>
                  </div>
                </div>

                {/* Full Description */}
                <div className={styles.transactionDescription}>
                  <p>{selectedTransaction.fullDescription}</p>
                </div>

                {/* Transaction Details */}
                <div className={styles.transactionDetails}>
                  <div className={styles.detailRow}>
                    <span className={styles.detailLabel}>User:</span>
                    <span 
                      className={styles.clickableUsername}
                      onClick={(e) => {
                        e.stopPropagation();
                        handleUsernameClick(selectedTransaction.username, e);
                        setShowTransactionModal(false);
                      }}
                      style={{ 
                        color: selectedTransaction.isBot ? '#10b981' : '#3b82f6', 
                        cursor: 'pointer',
                        textDecoration: 'underline'
                      }}
                    >
                      {selectedTransaction.isBot ? 'ðŸ¤– ' : 'ðŸ‘¤ '}{selectedTransaction.username}
                    </span>
                  </div>
                  
                  <div className={styles.detailRow}>
                    <span className={styles.detailLabel}>Time:</span>
                    <span>{new Date(selectedTransaction.timestamp).toLocaleString()}</span>
                  </div>

                  {selectedTransaction.opinionText && (
                    <div className={styles.detailRow}>
                      <span className={styles.detailLabel}>Opinion:</span>
                      <span className={styles.opinionText}>"{selectedTransaction.opinionText}"</span>
                    </div>
                  )}

                  {selectedTransaction.opinionId && (
                    <div className={styles.detailRow}>
                      <span className={styles.detailLabel}>Opinion ID:</span>
                      <span>#{selectedTransaction.opinionId}</span>
                    </div>
                  )}

                  {/* Show price and quantity details for trades */}
                  {(selectedTransaction.type === 'buy' || selectedTransaction.type === 'sell') && selectedTransaction.price && (
                    <>
                      <div className={styles.detailRow}>
                        <span className={styles.detailLabel}>Price per share:</span>
                        <span>${selectedTransaction.price.toFixed(2)}</span>
                      </div>
                      <div className={styles.detailRow}>
                        <span className={styles.detailLabel}>Quantity:</span>
                        <span>{selectedTransaction.quantity || 1} shares</span>
                      </div>
                      <div className={styles.detailRow}>
                        <span className={styles.detailLabel}>Total value:</span>
                        <span>${Math.abs(selectedTransaction.amount).toFixed(2)}</span>
                      </div>
                    </>
                  )}
                </div>

                {/* Action Buttons */}
                <div className={styles.modalActions}>
                  {selectedTransaction.username !== currentUser.username && (
                    <button
                      onClick={(e) => {
                        e.stopPropagation();
                        handleUsernameClick(selectedTransaction.username, e);
                        setShowTransactionModal(false);
                      }}
                      className={styles.viewUserButton}
                    >
                      ðŸ‘¤ View {selectedTransaction.isBot ? 'Bot' : 'User'} Profile
                    </button>
                  )}
                  
                  {selectedTransaction.opinionId && (
                    <button
                      onClick={() => {
                        router.push(`/opinion/${selectedTransaction.opinionId}`);
                        setShowTransactionModal(false);
                      }}
                      className={styles.viewOpinionButton}
                    >
                      ðŸ’¬ View Opinion
                    </button>
                  )}
                  
                  <button
                    onClick={() => {
                      setShowTransactionModal(false);
                      setSelectedTransaction(null);
                    }}
                    className={styles.closeModalButton}
                  >
                    Close
                  </button>
                </div>
              </div>
            </div>
          </div>
        )}

        {/* Market Stats */}
        <div className={styles.marketStats}>
          <div className={`${styles.statCard} ${styles.purchases}`}>
            <div className={`${styles.statNumber} ${styles.purchases}`}>
              {activityFeed.filter(a => a.type === 'buy').length}
            </div>
            <div className={styles.statLabel}>Total Purchases</div>
          </div>
          
          <div className={`${styles.statCard} ${styles.sales}`}>
            <div className={`${styles.statNumber} ${styles.sales}`}>
              {activityFeed.filter(a => a.type === 'sell').length}
            </div>
            <div className={styles.statLabel}>Total Sales</div>
          </div>
          
          <div className={`${styles.statCard} ${styles.bets}`}>
            <div className={`${styles.statNumber} ${styles.bets}`}>
              {activityFeed.filter(a => a.type.includes('bet')).length}
            </div>
            <div className={styles.statLabel}>Portfolio Bets</div>
          </div>

          <div className={`${styles.statCard} ${styles.shorts}`}>
            <div className={`${styles.statNumber} ${styles.shorts}`}>
              {shortActivityCount}
            </div>
            <div className={styles.statLabel}>Short Positions</div>
          </div>
          
          <div className={`${styles.statCard} ${styles.volume}`}>
            <div className={`${styles.statNumber} ${styles.volume}`}>
              ${activityFeed.reduce((sum, a) => sum + Math.abs(a.amount), 0).toFixed(2)}
            </div>
            <div className={styles.statLabel}>Total Volume</div>
          </div>
        </div>
      </main>
    </div>
  );
}
