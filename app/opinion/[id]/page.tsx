'use client';

import { useEffect, useState } from 'react';
import { useParams, useRouter } from 'next/navigation';
import Sidebar from '../../components/Sidebar';
import styles from './page.module.css';

interface UserProfile {
  username: string;
  balance: number;
  joinDate: string;
  totalEarnings: number;
  totalLosses: number;
}

interface OpinionAsset {
  id: string;
  text: string;
  purchasePrice: number;
  currentPrice: number;
  purchaseDate: string;
  quantity: number;
}

interface Transaction {
  id: string;
  type: 'buy' | 'sell' | 'earn' | 'bet_win' | 'bet_loss' | 'bet_place';
  opinionId?: string;
  opinionText?: string;
  betId?: string;
  amount: number;
  date: string;
}

interface OpinionMarketData {
  opinionText: string;
  timesPurchased: number;
  timesSold: number;
  currentPrice: number;
  basePrice: number;
  volatility: number;
  lastUpdated: string;
  priceHistory: { price: number; timestamp: string; action: 'buy' | 'sell' }[];
}

interface OpinionAttribution {
  author: string;
  isBot: boolean;
  dateCreated: string;
  source: 'user' | 'ai_generated' | 'bot_generated';
}

export default function OpinionPage() {
  const { id } = useParams();
  const router = useRouter();
  const [opinion, setOpinion] = useState<string | null>(null);
  const [opinions, setOpinions] = useState<{ id: string; text: string }[]>([]);
  const [userProfile, setUserProfile] = useState<UserProfile>({
    username: 'OpinionTrader123',
    balance: 10000,
    joinDate: new Date().toLocaleDateString(),
    totalEarnings: 0,
    totalLosses: 0
  });
  const [ownedOpinions, setOwnedOpinions] = useState<OpinionAsset[]>([]);
  const [currentPrice, setCurrentPrice] = useState<number>(10);
  const [sellPrice, setSellPrice] = useState<number>(0);
  const [timesPurchased, setTimesPurchased] = useState<number>(0);
  const [timesSold, setTimesSold] = useState<number>(0);
  const [message, setMessage] = useState<string>('');
  const [alreadyOwned, setAlreadyOwned] = useState<boolean>(false);
  const [ownedQuantity, setOwnedQuantity] = useState<number>(0);
  const [attribution, setAttribution] = useState<OpinionAttribution | null>(null);

  // Get attribution for an opinion
  const getOpinionAttribution = (opinionText: string, opinionIndex: number): OpinionAttribution => {
    try {
      // Check if attribution exists in localStorage
      const attributions = JSON.parse(localStorage.getItem('opinionAttributions') || '{}');
      
      if (attributions[opinionText]) {
        return attributions[opinionText];
      }
      
      // Check if this opinion was generated by a bot
      const botTransactions = JSON.parse(localStorage.getItem('botTransactions') || '[]');
      const botGenerated = botTransactions.find((t: any) => 
        t.type === 'earn' && t.opinionText === opinionText
      );
      
      if (botGenerated) {
        // Get bot username
        const bots = JSON.parse(localStorage.getItem('autonomousBots') || '[]');
        const bot = bots.find((b: any) => b.id === botGenerated.botId);
        
        return {
          author: bot ? bot.username : 'AI Bot',
          isBot: true,
          dateCreated: botGenerated.date || new Date().toLocaleDateString(),
          source: 'bot_generated'
        };
      }
      
      // Check if this was AI generated by human user
      const transactions = JSON.parse(localStorage.getItem('transactions') || '[]');
      const aiGenerated = transactions.find((t: any) => 
        t.type === 'earn' && 
        (t.opinionText === opinionText || t.description?.includes(opinionText.slice(0, 30)))
      );
      
      if (aiGenerated) {
        const currentUser = JSON.parse(localStorage.getItem('userProfile') || '{}');
        return {
          author: currentUser.username || 'OpinionTrader123',
          isBot: false,
          dateCreated: aiGenerated.date || new Date().toLocaleDateString(),
          source: 'ai_generated'
        };
      }
      
      // Default attribution for existing opinions without clear attribution
      const currentUser = JSON.parse(localStorage.getItem('userProfile') || '{}');
      return {
        author: currentUser.username || 'OpinionTrader123',
        isBot: false,
        dateCreated: new Date().toLocaleDateString(),
        source: 'user'
      };
      
    } catch (error) {
      console.error('Error getting opinion attribution:', error);
      const currentUser = JSON.parse(localStorage.getItem('userProfile') || '{}');
      return {
        author: currentUser.username || 'Anonymous',
        isBot: false,
        dateCreated: new Date().toLocaleDateString(),
        source: 'user'
      };
    }
  };

  // Save attribution for an opinion
  const saveOpinionAttribution = (opinionText: string, attribution: OpinionAttribution) => {
    try {
      const attributions = JSON.parse(localStorage.getItem('opinionAttributions') || '{}');
      attributions[opinionText] = attribution;
      localStorage.setItem('opinionAttributions', JSON.stringify(attributions));
    } catch (error) {
      console.error('Error saving opinion attribution:', error);
    }
  };

  // Enhanced pricing algorithm
  const calculatePrice = (timesPurchased: number, timesSold: number, basePrice: number = 10, volatility: number = 1): number => {
    // Net demand = purchases - sales
    const netDemand = timesPurchased - timesSold;
    
    // Exponential growth for high demand, decay for negative demand
    let priceMultiplier;
    if (netDemand >= 0) {
      priceMultiplier = Math.pow(1.15, netDemand) * volatility;
    } else {
      priceMultiplier = Math.max(0.1, Math.pow(0.9, Math.abs(netDemand))) * volatility;
    }
    
    // Minimum price floor
    const calculatedPrice = Math.max(basePrice * 0.5, basePrice * priceMultiplier);
    
    return Math.round(calculatedPrice);
  };

  // Calculate sell price (typically 85-95% of current market price based on liquidity)
  const calculateSellPrice = (currentPrice: number, timesPurchased: number): number => {
    // Higher liquidity (more purchases) = better sell price
    const liquidityBonus = Math.min(0.1, timesPurchased * 0.01);
    const sellRatio = 0.85 + liquidityBonus; // 85% base + up to 10% liquidity bonus
    
    return Math.round(currentPrice * sellRatio);
  };

  // Calculate opinion volatility based on content
  const calculateVolatility = (opinionText: string): number => {
    const text = opinionText.toLowerCase();
    let volatility = 1.0;
    
    // High volatility keywords
    if (text.includes('crypto') || text.includes('bitcoin') || text.includes('stock')) volatility += 0.5;
    if (text.includes('controversial') || text.includes('hot take') || text.includes('unpopular')) volatility += 0.3;
    if (text.includes('prediction') || text.includes('will') || text.includes('future')) volatility += 0.2;
    if (text.includes('politics') || text.includes('election')) volatility += 0.4;
    
    // Low volatility keywords
    if (text.includes('safe') || text.includes('boring') || text.includes('obvious')) volatility -= 0.2;
    if (text.includes('traditional') || text.includes('conservative')) volatility -= 0.1;
    
    return Math.max(0.5, Math.min(2.0, volatility));
  };

  // Get market data for an opinion
  const getOpinionMarketData = (opinionText: string): OpinionMarketData => {
    const marketData = JSON.parse(localStorage.getItem('opinionMarketData') || '{}');
    
    if (marketData[opinionText]) {
      return marketData[opinionText];
    } else {
      const basePrice = 10;
      const volatility = calculateVolatility(opinionText);
      
      return {
        opinionText,
        timesPurchased: 0,
        timesSold: 0,
        currentPrice: basePrice,
        basePrice,
        volatility,
        lastUpdated: new Date().toISOString(),
        priceHistory: []
      };
    }
  };

  // Update market data for an opinion
  const updateOpinionMarketData = (opinionText: string, action: 'buy' | 'sell'): OpinionMarketData => {
    const marketData = JSON.parse(localStorage.getItem('opinionMarketData') || '{}');
    const currentData = getOpinionMarketData(opinionText);
    
    const newTimesPurchased = action === 'buy' ? currentData.timesPurchased + 1 : currentData.timesPurchased;
    const newTimesSold = action === 'sell' ? currentData.timesSold + 1 : currentData.timesSold;
    const newPrice = calculatePrice(newTimesPurchased, newTimesSold, currentData.basePrice, currentData.volatility);
    
    const updatedData: OpinionMarketData = {
      ...currentData,
      timesPurchased: newTimesPurchased,
      timesSold: newTimesSold,
      currentPrice: newPrice,
      lastUpdated: new Date().toISOString(),
      priceHistory: [
        ...currentData.priceHistory.slice(-19), // Keep last 20 entries
        { price: newPrice, timestamp: new Date().toISOString(), action }
      ]
    };
    
    marketData[opinionText] = updatedData;
    localStorage.setItem('opinionMarketData', JSON.stringify(updatedData));
    
    return updatedData;
  };

  // Update all owned opinions with new market prices
  const updateOwnedOpinionPrices = () => {
    const storedAssets = localStorage.getItem('ownedOpinions');
    if (!storedAssets) return;
    
    const owned = JSON.parse(storedAssets);
    const updatedOwned = owned.map((asset: OpinionAsset) => {
      const marketData = getOpinionMarketData(asset.text);
      return {
        ...asset,
        currentPrice: marketData.currentPrice
      };
    });
    
    setOwnedOpinions(updatedOwned);
    localStorage.setItem('ownedOpinions', JSON.stringify(updatedOwned));
  };

  useEffect(() => {
    if (typeof id !== 'string') {
      setOpinion('Opinion not found.');
      return;
    }

    try {
      const stored = localStorage.getItem('opinions');
      if (!stored) {
        setOpinion('Opinion not found.');
        setOpinions([]);
        return;
      }

      const all = JSON.parse(stored);
      const mappedOpinions = all.map((text: string, i: number) => ({
        id: i.toString(),
        text,
      }));
      setOpinions(mappedOpinions);

      const idx = parseInt(id, 10);
      if (!isNaN(idx) && all[idx] !== undefined) {
        const currentOpinion = all[idx];
        setOpinion(currentOpinion);
        
        // Get and set attribution
        const opinionAttribution = getOpinionAttribution(currentOpinion, idx);
        setAttribution(opinionAttribution);
        saveOpinionAttribution(currentOpinion, opinionAttribution);
        
        const marketData = getOpinionMarketData(currentOpinion);
        setCurrentPrice(marketData.currentPrice);
        setSellPrice(calculateSellPrice(marketData.currentPrice, marketData.timesPurchased));
        setTimesPurchased(marketData.timesPurchased);
        setTimesSold(marketData.timesSold);
      } else {
        setOpinion('Opinion not found.');
      }

      const storedProfile = localStorage.getItem('userProfile');
      if (storedProfile) {
        setUserProfile(JSON.parse(storedProfile));
      }

      updateOwnedOpinionPrices();
      
      const storedAssets = localStorage.getItem('ownedOpinions');
      if (storedAssets && all[idx]) {
        const owned = JSON.parse(storedAssets);
        const ownedAsset = owned.find((asset: OpinionAsset) => 
          asset.text === all[idx]
        );
        if (ownedAsset) {
          setAlreadyOwned(true);
          setOwnedQuantity(ownedAsset.quantity);
        }
      }

    } catch (error) {
      console.error('Error loading opinion data:', error);
      setOpinion('Error loading opinion.');
    }
  }, [id]);

  const purchaseOpinion = () => {
    if (!opinion) return;

    if (userProfile.balance < currentPrice) {
      setMessage('Insufficient funds! Generate more opinions to earn money.');
      setTimeout(() => setMessage(''), 5000);
      return;
    }

    const updatedMarketData = updateOpinionMarketData(opinion, 'buy');

    // If user already owns this opinion, increase quantity
    if (alreadyOwned) {
      const updatedOwnedOpinions = ownedOpinions.map(asset => {
        if (asset.text === opinion) {
          return {
            ...asset,
            quantity: asset.quantity + 1,
            currentPrice: updatedMarketData.currentPrice
          };
        }
        return asset;
      });
      setOwnedOpinions(updatedOwnedOpinions);
      setOwnedQuantity(ownedQuantity + 1);
      localStorage.setItem('ownedOpinions', JSON.stringify(updatedOwnedOpinions));
    } else {
      // Create new asset
      const newAsset: OpinionAsset = {
        id: Date.now().toString(),
        text: opinion,
        purchasePrice: currentPrice,
        currentPrice: updatedMarketData.currentPrice,
        purchaseDate: new Date().toLocaleDateString(),
        quantity: 1
      };

      const updatedOwnedOpinions = [...ownedOpinions, newAsset];
      setOwnedOpinions(updatedOwnedOpinions);
      localStorage.setItem('ownedOpinions', JSON.stringify(updatedOwnedOpinions));
      setAlreadyOwned(true);
      setOwnedQuantity(1);
    }

    const newTransaction: Transaction = {
      id: Date.now().toString(),
      type: 'buy',
      opinionText: opinion.length > 50 ? opinion.slice(0, 50) + '...' : opinion,
      amount: -currentPrice,
      date: new Date().toLocaleDateString()
    };

    updateOwnedOpinionPrices();

    const updatedProfile = {
      ...userProfile,
      balance: userProfile.balance - currentPrice
    };
    setUserProfile(updatedProfile);
    localStorage.setItem('userProfile', JSON.stringify(updatedProfile));

    const existingTransactions = JSON.parse(localStorage.getItem('transactions') || '[]');
    const updatedTransactions = [newTransaction, ...existingTransactions.slice(0, 9)];
    localStorage.setItem('transactions', JSON.stringify(updatedTransactions));

    const oldPrice = currentPrice;
    setCurrentPrice(updatedMarketData.currentPrice);
    setSellPrice(calculateSellPrice(updatedMarketData.currentPrice, updatedMarketData.timesPurchased));
    setTimesPurchased(updatedMarketData.timesPurchased);
    
    setMessage(`Successfully purchased! Price increased from $${oldPrice} to $${updatedMarketData.currentPrice}.`);
    setTimeout(() => setMessage(''), 7000);
  };

  const sellOpinion = () => {
    if (!opinion || !alreadyOwned || ownedQuantity === 0) return;

    const updatedMarketData = updateOpinionMarketData(opinion, 'sell');

    // Update owned opinions - decrease quantity or remove if 0
    const updatedOwnedOpinions = ownedOpinions.map(asset => {
      if (asset.text === opinion) {
        const newQuantity = asset.quantity - 1;
        return {
          ...asset,
          quantity: newQuantity,
          currentPrice: updatedMarketData.currentPrice
        };
      }
      return asset;
    }).filter(asset => asset.quantity > 0);

    setOwnedOpinions(updatedOwnedOpinions);
    localStorage.setItem('ownedOpinions', JSON.stringify(updatedOwnedOpinions));

    const newQuantity = ownedQuantity - 1;
    setOwnedQuantity(newQuantity);
    if (newQuantity === 0) {
      setAlreadyOwned(false);
    }

    const newTransaction: Transaction = {
      id: Date.now().toString(),
      type: 'sell',
      opinionText: opinion.length > 50 ? opinion.slice(0, 50) + '...' : opinion,
      amount: sellPrice,
      date: new Date().toLocaleDateString()
    };

    updateOwnedOpinionPrices();

    const updatedProfile = {
      ...userProfile,
      balance: userProfile.balance + sellPrice,
      totalEarnings: userProfile.totalEarnings + sellPrice
    };
    setUserProfile(updatedProfile);
    localStorage.setItem('userProfile', JSON.stringify(updatedProfile));

    const existingTransactions = JSON.parse(localStorage.getItem('transactions') || '[]');
    const updatedTransactions = [newTransaction, ...existingTransactions.slice(0, 9)];
    localStorage.setItem('transactions', JSON.stringify(updatedTransactions));

    const oldPrice = currentPrice;
    setCurrentPrice(updatedMarketData.currentPrice);
    setSellPrice(calculateSellPrice(updatedMarketData.currentPrice, updatedMarketData.timesPurchased));
    setTimesSold(updatedMarketData.timesSold);
    
    setMessage(`Successfully sold for ${sellPrice}! Market price adjusted from ${oldPrice} to ${updatedMarketData.currentPrice}.`);
    setTimeout(() => setMessage(''), 7000);
  };

  const getMarketTrend = () => {
    const netDemand = timesPurchased - timesSold;
    if (netDemand > 5) return { emoji: 'üöÄ', text: 'Bullish', color: 'bullish', class: 'bullish' };
    if (netDemand > 2) return { emoji: 'üìà', text: 'Rising', color: 'bullish', class: 'bullish' };
    if (netDemand > -2) return { emoji: '‚û°Ô∏è', text: 'Stable', color: 'stable', class: 'stable' };
    if (netDemand > -5) return { emoji: 'üìâ', text: 'Declining', color: 'bearish', class: 'bearish' };
    return { emoji: 'üíÄ', text: 'Bearish', color: 'bearish', class: 'bearish' };
  };

  const getMessageClass = (message: string) => {
    if (message.includes('Successfully')) return 'success';
    if (message.includes('Insufficient')) return 'error';
    return 'warning';
  };

  const getAuthorDisplay = (attribution: OpinionAttribution) => {
    if (attribution.isBot) {
      return {
        name: attribution.author,
        icon: 'ü§ñ',
        description: 'Autonomous Trading Bot',
        class: 'bot'
      };
    } else if (attribution.source === 'ai_generated') {
      return {
        name: attribution.author,
        icon: '‚ú®',
        description: 'AI Generated',
        class: 'ai'
      };
    } else {
      return {
        name: attribution.author,
        icon: 'üë§',
        description: 'User Created',
        class: 'user'
      };
    }
  };

  const trend = getMarketTrend();

  return (
    <div className="page-container">
      <Sidebar opinions={opinions} />
      
      <main className="main-content">
        {/* Header with Navigation */}
        <div className={styles.pageHeader}>
          <button
            onClick={() => router.push('/')}
            className={styles.backButton}
          >
            ‚Üê Back to Profile
          </button>

          <div className={styles.headerActions}>
            {/* Navigation Buttons */}
            <a href="/users" className="nav-button traders">
              üìä View Traders
            </a>
            <a href="/feed" className="nav-button feed">
              üì° Live Feed
            </a>
            <a href="/generate" className="nav-button generate">
              ‚ú® Generate
            </a>

            {/* Wallet Display */}
            <div className={styles.walletDisplay}>
              <p>üí∞ Wallet</p>
              <p>${userProfile.balance.toLocaleString()}</p>
            </div>
          </div>
        </div>

        {/* Main Opinion Card */}
        <div className={styles.opinionCard}>
          <div className={styles.opinionHeader}>
            <h1 className={styles.opinionTitle}>üí¨ Opinion #{id}</h1>
            {alreadyOwned && (
              <div className={styles.ownedBadge}>
                ‚úÖ Owned: {ownedQuantity}
              </div>
            )}
          </div>
          
          <div className={styles.opinionText}>
            <p>"{opinion}"</p>
          </div>

          {/* Attribution Section */}
          {attribution && (
            <div className={styles.attributionSection}>
              <div className={`${styles.attributionCard} ${styles[getAuthorDisplay(attribution).class]}`}>
                <div className={styles.attributionIcon}>
                  {getAuthorDisplay(attribution).icon}
                </div>
                <div className={styles.attributionDetails}>
                  <div className={styles.attributionAuthor}>
                    {getAuthorDisplay(attribution).name}
                  </div>
                  <div className={styles.attributionMeta}>
                    {getAuthorDisplay(attribution).description} ‚Ä¢ Created {attribution.dateCreated}
                  </div>
                </div>
              </div>
            </div>
          )}

          {/* Price Chart */}
          <div className={styles.chartContainer}>
            <h3 className={styles.chartTitle}>üìà Price History Chart</h3>
            
            {(() => {
              if (!opinion) return null;
              
              const marketData = getOpinionMarketData(opinion);
              const priceHistory = marketData.priceHistory || [];
              
              // Create chart data with at least current price
              let chartData = [];
              if (priceHistory.length > 0) {
                chartData = priceHistory.map(item => ({
                  price: item.price,
                  date: new Date(item.timestamp).toLocaleDateString(),
                  time: new Date(item.timestamp).toLocaleTimeString(),
                  action: item.action
                }));
              } else {
                // Show base price and current price if no history
                chartData = [
                  { price: marketData.basePrice, date: 'Start', time: '', action: 'base' },
                  { price: currentPrice, date: 'Now', time: '', action: 'current' }
                ];
              }
              
              if (chartData.length === 0) {
                return (
                  <div className={styles.chartEmpty}>
                    <div>üìä</div>
                    <h4>No Trading Data Yet</h4>
                    <p>Chart will appear after first purchase or sale</p>
                  </div>
                );
              }
              
              // Calculate price range for visual scaling
              const prices = chartData.map(d => d.price);
              const minPrice = Math.min(...prices);
              const maxPrice = Math.max(...prices);
              const priceRange = maxPrice - minPrice;
              const firstPrice = prices[0];
              const lastPrice = prices[prices.length - 1];
              const totalChange = lastPrice - firstPrice;
              const totalChangePercent = firstPrice > 0 ? ((totalChange / firstPrice) * 100) : 0;
              
              // Simple bar chart representation
              const maxBarHeight = 150;
              
              return (
                <div>
                  {/* Chart Summary */}
                  <div className={styles.chartSummary}>
                    <div className={styles.summaryItem}>
                      <div className={styles.summaryLabel}>Starting Price</div>
                      <div className={styles.summaryValue}>${firstPrice}</div>
                    </div>
                    <div className={styles.summaryItem}>
                      <div className={styles.summaryLabel}>Current Price</div>
                      <div className={styles.summaryValue}>${lastPrice}</div>
                    </div>
                    <div className={styles.summaryItem}>
                      <div className={styles.summaryLabel}>Total Change</div>
                      <div className={`${styles.summaryValue} ${totalChange >= 0 ? styles.positive : styles.negative}`}>
                        {totalChange >= 0 ? '+' : ''}${totalChange.toFixed(1)} ({totalChangePercent >= 0 ? '+' : ''}{totalChangePercent.toFixed(1)}%)
                      </div>
                    </div>
                    <div className={styles.summaryItem}>
                      <div className={styles.summaryLabel}>Data Points</div>
                      <div className={styles.summaryValue}>{chartData.length}</div>
                    </div>
                  </div>
                  
                  {/* Simple Visual Chart */}
                  <div className={styles.chartVisual}>
                    {/* Y-axis labels */}
                    <div className={`${styles.yAxisLabel} ${styles.top}`}>
                      ${maxPrice}
                    </div>
                    <div className={`${styles.yAxisLabel} ${styles.bottom}`}>
                      ${minPrice}
                    </div>
                    
                    {chartData.map((dataPoint, index) => {
                      const barHeight = priceRange > 0 
                        ? ((dataPoint.price - minPrice) / priceRange) * maxBarHeight 
                        : maxBarHeight / 2;
                      const isIncrease = index === 0 || dataPoint.price >= chartData[index - 1].price;
                      
                      return (
                        <div key={index} className={styles.chartBar}>
                          {/* Price label on top */}
                          <div className={`${styles.barLabel} ${isIncrease ? styles.positive : styles.negative}`}>
                            ${dataPoint.price}
                          </div>
                          
                          {/* Bar */}
                          <div
                            className={`${styles.bar} ${isIncrease ? styles.positive : styles.negative}`}
                            style={{ height: `${barHeight}px` }}
                            title={`${dataPoint.price} - ${dataPoint.date} ${dataPoint.time}`}
                          />
                          
                          {/* Date label */}
                          <div className={styles.barDate}>
                            {dataPoint.date}
                          </div>
                        </div>
                      );
                    })}
                  </div>
                  
                  {/* Legend */}
                  <div className={styles.chartLegend}>
                    <div className={styles.legendItem}>
                      <div className={`${styles.legendColor} ${styles.positive}`}></div>
                      <span>Price Increase</span>
                    </div>
                    <div className={styles.legendItem}>
                      <div className={`${styles.legendColor} ${styles.negative}`}></div>
                      <span>Price Decrease</span>
                    </div>
                  </div>
                </div>
              );
            })()}
          </div>

          {/* Market Stats */}
          <div className={styles.marketStats}>
            <div className={`${styles.statCard} ${styles.price}`}>
              <h3 className={`${styles.statTitle} ${styles.price}`}>üí∞ Current Price</h3>
              <p className={styles.statValue}>${currentPrice}</p>
              <p className={styles.statSubtext}>Base price: $10</p>
            </div>

            <div className={`${styles.statCard} ${styles.trend}`}>
              <h3 className={`${styles.statTitle} ${styles.trend}`}>üìä Market Trend</h3>
              <p className={`${styles.statValue} ${styles[trend.class]}`}>
                {trend.emoji} {trend.text}
              </p>
              <p className={styles.statSubtext}>
                Net demand: {timesPurchased - timesSold}
              </p>
            </div>

            <div className={`${styles.statCard} ${styles.volume}`}>
              <h3 className={`${styles.statTitle} ${styles.volume}`}>üîÑ Trading Volume</h3>
              <p className={styles.statValue}>
                {timesPurchased} buys
              </p>
              <p className={styles.statSubtext}>
                {timesSold} sells
              </p>
            </div>

            {alreadyOwned && (
              <div className={`${styles.statCard} ${styles.sell}`}>
                <h3 className={`${styles.statTitle} ${styles.sell}`}>üí∏ Sell Price</h3>
                <p className={styles.statValue}>${sellPrice}</p>
                <p className={styles.statSubtext}>
                  {Math.round((sellPrice / currentPrice) * 100)}% of market price
                </p>
              </div>
            )}
          </div>

          {/* Action Buttons */}
          <div className={styles.actionButtons}>
            {!alreadyOwned || ownedQuantity === 0 ? (
              <button
                onClick={purchaseOpinion}
                disabled={userProfile.balance < currentPrice}
                className={`${styles.actionButton} ${styles.buy}`}
              >
                {userProfile.balance < currentPrice 
                  ? `Need ${currentPrice - userProfile.balance} more`
                  : `Buy for ${currentPrice}`
                }
              </button>
            ) : (
              <>
                <button
                  onClick={purchaseOpinion}
                  disabled={userProfile.balance < currentPrice}
                  className={`${styles.actionButton} ${styles.buyMore}`}
                >
                  {userProfile.balance < currentPrice 
                    ? `Need ${currentPrice - userProfile.balance} more`
                    : `Buy More (${currentPrice})`
                  }
                </button>
                
                <button
                  onClick={sellOpinion}
                  className={`${styles.actionButton} ${styles.sell}`}
                >
                  Sell 1 for ${sellPrice}
                </button>
              </>
            )}
          </div>
        </div>

        {/* Status Messages */}
        {message && (
          <div className={`${styles.statusMessage} ${styles[getMessageClass(message)]}`}>
            {message}
          </div>
        )}

        {/* Enhanced Trading Info */}
        <div className={styles.tradingInfo}>
          <p>üí° <strong>Enhanced Trading System:</strong></p>
          <div className={styles.tradingInfoGrid}>
            <div className={styles.tradingInfoSection}>
              <strong>Dynamic Pricing:</strong>
              <ul>
                <li>Prices rise exponentially with net demand</li>
                <li>Volatility based on opinion content</li>
                <li>Selling pressure reduces prices</li>
              </ul>
            </div>
            <div className={styles.tradingInfoSection}>
              <strong>Selling Mechanism:</strong>
              <ul>
                <li>Sell price is 85-95% of market price</li>
                <li>Higher liquidity = better sell ratios</li>
                <li>Each sale affects market price</li>
              </ul>
            </div>
          </div>
        </div>
      </main>
    </div>
  );
}